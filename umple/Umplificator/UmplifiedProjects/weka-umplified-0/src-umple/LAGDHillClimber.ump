namespace weka.classifiers.bayes.net.search.local;

class LAGDHillClimber
{
  isA HillClimber;
 depend java.util.Collections;
 depend java.util.Enumeration;
 depend java.util.Vector;
 depend weka.classifiers.bayes.BayesNet;
 depend weka.core.Instances;
 depend weka.core.Option;
 depend weka.core.RevisionUtils;
 depend weka.core.Utils;
/** 
 * for serialization 
 */
static final long serialVersionUID=7217437499439184344L;

/** 
 * Number of Look Ahead Steps 
 */
int m_nNrOfLookAheadSteps=2;

/** 
 * Number of Good Operations per Step 
 */
int m_nNrOfGoodOperations=5;

/** 
 * search determines the network structure/graph of the network
 * @param bayesNet the network
 * @param instances the data to use
 * @throws Exception if something goes wrong
 */
@Override protected void search(BayesNet bayesNet,Instances instances) throws Exception {
  int k=m_nNrOfLookAheadSteps;
  int l=m_nNrOfGoodOperations;
  lookAheadInGoodDirectionsSearch(bayesNet,instances,k,l);
}

/** 
 * lookAheadInGoodDirectionsSearch determines the network structure/graph of the network with best score according to LAGD Hill Climbing
 * @param bayesNet the network
 * @param instances the data to use
 * @param nrOfLookAheadSteps
 * @param nrOfGoodOperations
 * @throws Exception if something goes wrong
 */
protected void lookAheadInGoodDirectionsSearch(BayesNet bayesNet,Instances instances,int nrOfLookAheadSteps,int nrOfGoodOperations) throws Exception {
  System.out.println("Initializing Cache");
  initCache(bayesNet,instances);
  while (nrOfLookAheadSteps > 1) {
    System.out.println("Look Ahead Depth: " + nrOfLookAheadSteps);
    boolean legalSequence=true;
    double sequenceDeltaScore=0;
    Operation[] bestOperation=new Operation[nrOfLookAheadSteps];
    bestOperation=getOptimalOperations(bayesNet,instances,nrOfLookAheadSteps,nrOfGoodOperations);
    for (int i=0; i < nrOfLookAheadSteps; i++) {
      if (bestOperation[i] == null) {
        legalSequence=false;
      }
 else {
        sequenceDeltaScore+=bestOperation[i].m_fDeltaScore;
      }
    }
    while (legalSequence && sequenceDeltaScore > 0) {
      System.out.println("Next Iteration..........................");
      for (int i=0; i < nrOfLookAheadSteps; i++) {
        performOperation(bayesNet,instances,bestOperation[i]);
      }
      bestOperation=getOptimalOperations(bayesNet,instances,nrOfLookAheadSteps,nrOfGoodOperations);
      sequenceDeltaScore=0;
      for (int i=0; i < nrOfLookAheadSteps; i++) {
        if (bestOperation[i] != null) {
          System.out.println(bestOperation[i].m_nOperation + " " + bestOperation[i].m_nHead+ " "+ bestOperation[i].m_nTail);
          sequenceDeltaScore+=bestOperation[i].m_fDeltaScore;
        }
 else {
          legalSequence=false;
        }
        System.out.println("DeltaScore: " + sequenceDeltaScore);
      }
    }
    --nrOfLookAheadSteps;
  }
  Operation oOperation=getOptimalOperation(bayesNet,instances);
  while ((oOperation != null) && (oOperation.m_fDeltaScore > 0)) {
    performOperation(bayesNet,instances,oOperation);
    System.out.println("Performing last greedy steps");
    oOperation=getOptimalOperation(bayesNet,instances);
  }
  m_Cache=null;
}

/** 
 * getAntiOperation determines the Operation, which is needed to cancel oOperation
 * @param oOperation Operation to cancel
 * @return antiOperation to oOperation
 * @throws Exception if something goes wrong
 */
protected Operation getAntiOperation(Operation oOperation) throws Exception {
  if (oOperation.m_nOperation == Operation.OPERATION_ADD) {
    return (new Operation(oOperation.m_nTail,oOperation.m_nHead,Operation.OPERATION_DEL));
  }
 else {
    if (oOperation.m_nOperation == Operation.OPERATION_DEL) {
      return (new Operation(oOperation.m_nTail,oOperation.m_nHead,Operation.OPERATION_ADD));
    }
 else {
      return (new Operation(oOperation.m_nHead,oOperation.m_nTail,Operation.OPERATION_REVERSE));
    }
  }
}

/** 
 * getGoodOperations determines the nrOfGoodOperations best Operations, which are considered for the calculation of an optimal operationsequence
 * @param bayesNet Bayes network to apply operation on
 * @param instances data set to learn from
 * @param nrOfGoodOperations number of good operations to consider
 * @return good operations to consider
 * @throws Exception if something goes wrong
 */
protected Operation[] getGoodOperations(BayesNet bayesNet,Instances instances,int nrOfGoodOperations) throws Exception {
  Operation[] goodOperations=new Operation[nrOfGoodOperations];
  for (int i=0; i < nrOfGoodOperations; i++) {
    goodOperations[i]=getOptimalOperation(bayesNet,instances);
    if (goodOperations[i] != null) {
      m_Cache.put(goodOperations[i],-1E100);
    }
 else {
      i=nrOfGoodOperations;
    }
  }
  for (int i=0; i < nrOfGoodOperations; i++) {
    if (goodOperations[i] != null) {
      if (goodOperations[i].m_nOperation != Operation.OPERATION_REVERSE) {
        m_Cache.put(goodOperations[i],goodOperations[i].m_fDeltaScore);
      }
 else {
        m_Cache.put(goodOperations[i],goodOperations[i].m_fDeltaScore - m_Cache.m_fDeltaScoreAdd[goodOperations[i].m_nHead][goodOperations[i].m_nTail]);
      }
    }
 else {
      i=nrOfGoodOperations;
    }
  }
  return goodOperations;
}

/** 
 * getOptimalOperations determines an optimal operationsequence in respect of the parameters nrOfLookAheadSteps and nrOfGoodOperations
 * @param bayesNet Bayes network to apply operation on
 * @param instances data set to learn from
 * @param nrOfLookAheadSteps number of lood ahead steps to use
 * @param nrOfGoodOperations number of good operations to consider
 * @return optimal sequence of operations in respect to nrOfLookAheadSteps andnrOfGoodOperations
 * @throws Exception if something goes wrong
 */
protected Operation[] getOptimalOperations(BayesNet bayesNet,Instances instances,int nrOfLookAheadSteps,int nrOfGoodOperations) throws Exception {
  if (nrOfLookAheadSteps == 1) {
    Operation[] bestOperation=new Operation[1];
    bestOperation[0]=getOptimalOperation(bayesNet,instances);
    return (bestOperation);
  }
 else {
    double bestDeltaScore=0;
    double currentDeltaScore=0;
    Operation[] bestOperation=new Operation[nrOfLookAheadSteps];
    Operation[] goodOperations=new Operation[nrOfGoodOperations];
    Operation[] tempOperation=new Operation[nrOfLookAheadSteps - 1];
    goodOperations=getGoodOperations(bayesNet,instances,nrOfGoodOperations);
    for (int i=0; i < nrOfGoodOperations; i++) {
      if (goodOperations[i] != null) {
        performOperation(bayesNet,instances,goodOperations[i]);
        tempOperation=getOptimalOperations(bayesNet,instances,nrOfLookAheadSteps - 1,nrOfGoodOperations);
        currentDeltaScore=goodOperations[i].m_fDeltaScore;
        for (int j=0; j < nrOfLookAheadSteps - 1; j++) {
          if (tempOperation[j] != null) {
            currentDeltaScore+=tempOperation[j].m_fDeltaScore;
          }
        }
        performOperation(bayesNet,instances,getAntiOperation(goodOperations[i]));
        if (currentDeltaScore > bestDeltaScore) {
          bestDeltaScore=currentDeltaScore;
          bestOperation[0]=goodOperations[i];
          for (int j=1; j < nrOfLookAheadSteps; j++) {
            bestOperation[j]=tempOperation[j - 1];
          }
        }
      }
 else {
        i=nrOfGoodOperations;
      }
    }
    return (bestOperation);
  }
}

/** 
 * Sets the max number of parents
 * @param nMaxNrOfParents the max number of parents
 */
@Override public void setMaxNrOfParents(int nMaxNrOfParents){
  m_nMaxNrOfParents=nMaxNrOfParents;
}

/** 
 * Gets the max number of parents.
 * @return the max number of parents
 */
@Override public int getMaxNrOfParents(){
  return m_nMaxNrOfParents;
}

/** 
 * Sets the number of look-ahead steps
 * @param nNrOfLookAheadSteps the number of look-ahead steps
 */
public void setNrOfLookAheadSteps(int nNrOfLookAheadSteps){
  m_nNrOfLookAheadSteps=nNrOfLookAheadSteps;
}

/** 
 * Gets the number of look-ahead steps
 * @return the number of look-ahead step
 */
public int getNrOfLookAheadSteps(){
  return m_nNrOfLookAheadSteps;
}

/** 
 * Sets the number of "good operations"
 * @param nNrOfGoodOperations the number of "good operations"
 */
public void setNrOfGoodOperations(int nNrOfGoodOperations){
  m_nNrOfGoodOperations=nNrOfGoodOperations;
}

/** 
 * Gets the number of "good operations"
 * @return the number of "good operations"
 */
public int getNrOfGoodOperations(){
  return m_nNrOfGoodOperations;
}

/** 
 * Returns an enumeration describing the available options.
 * @return an enumeration of all the available options.
 */
@Override public Enumeration<Option> listOptions(){
  Vector<Option> newVector=new Vector<Option>(2);
  newVector.addElement(new Option("\tLook Ahead Depth","L",2,"-L <nr of look ahead steps>"));
  newVector.addElement(new Option("\tNr of Good Operations","G",5,"-G <nr of good operations>"));
  newVector.addAll(Collections.list(super.listOptions()));
  return newVector.elements();
}

/** 
 * Parses a given list of options. Valid options are: <p> <!-- options-start --> Valid options are: <p/> <pre> -L &lt;nr of look ahead steps&gt; Look Ahead Depth </pre> <pre> -G &lt;nr of good operations&gt; Nr of Good Operations </pre> <pre> -P &lt;nr of parents&gt; Maximum number of parents </pre> <pre> -R Use arc reversal operation. (default false) </pre> <pre> -N Initial structure is empty (instead of Naive Bayes) </pre> <pre> -mbc Applies a Markov Blanket correction to the network structure,  after a network structure is learned. This ensures that all  nodes in the network are part of the Markov blanket of the  classifier node. </pre> <pre> -S [BAYES|MDL|ENTROPY|AIC|CROSS_CLASSIC|CROSS_BAYES] Score type (BAYES, BDeu, MDL, ENTROPY and AIC) </pre> <!-- options-end -->
 * @param options the list of options as an array of strings
 * @throws Exception if an option is not supported
 */
@Override public void setOptions(String[] options) throws Exception {
  String sNrOfLookAheadSteps=Utils.getOption('L',options);
  if (sNrOfLookAheadSteps.length() != 0) {
    setNrOfLookAheadSteps(Integer.parseInt(sNrOfLookAheadSteps));
  }
 else {
    setNrOfLookAheadSteps(2);
  }
  String sNrOfGoodOperations=Utils.getOption('G',options);
  if (sNrOfGoodOperations.length() != 0) {
    setNrOfGoodOperations(Integer.parseInt(sNrOfGoodOperations));
  }
 else {
    setNrOfGoodOperations(5);
  }
  super.setOptions(options);
}

/** 
 * Gets the current settings of the search algorithm.
 * @return an array of strings suitable for passing to setOptions
 */
@Override public String[] getOptions(){
  Vector<String> options=new Vector<String>();
  options.add("-L");
  options.add("" + m_nNrOfLookAheadSteps);
  options.add("-G");
  options.add("" + m_nNrOfGoodOperations);
  Collections.addAll(options,super.getOptions());
  return options.toArray(new String[0]);
}

/** 
 * This will return a string describing the search algorithm.
 * @return The string.
 */
@Override public String globalInfo(){
  return "This Bayes Network learning algorithm uses a Look Ahead Hill Climbing algorithm called LAGD Hill Climbing." + " Unlike Greedy Hill Climbing it doesn't calculate a best greedy operation (adding, deleting or reversing an arc) " + "but a sequence of nrOfLookAheadSteps operations, which leads to a network structure whose score is most likely "+ "higher in comparison to the network obtained by performing a sequence of nrOfLookAheadSteps greedy operations. "+ "The search is not restricted by an order "+ "on the variables (unlike K2). The difference with B and B2 is that this hill "+ "climber also considers arrows part of the naive Bayes structure for deletion.";
}

/** 
 * @return a string to describe the Number of Look Ahead Steps option.
 */
public String nrOfLookAheadStepsTipText(){
  return "Sets the Number of Look Ahead Steps. 'nrOfLookAheadSteps = 2' means that all network structures in a " + "distance of 2 (from the current network structure) are taken into account for the decision which arcs to add, " + "remove or reverse. 'nrOfLookAheadSteps = 1' results in Greedy Hill Climbing.";
}

/** 
 * @return a string to describe the Number of Good Operations option.
 */
public String nrOfGoodOperationsTipText(){
  return "Sets the Number of Good Operations per Look Ahead Step. 'nrOfGoodOperations = 5' means that for the next " + "Look Ahead Step only the 5 best Operations (adding, deleting or reversing an arc) are taken into account for the " + "calculation of the best sequence consisting of nrOfLookAheadSteps operations.";
}

/** 
 * Returns the revision string.
 * @return the revision
 */
@Override public String getRevision(){
  return RevisionUtils.extract("$Revision: 10154 $");
}
}
