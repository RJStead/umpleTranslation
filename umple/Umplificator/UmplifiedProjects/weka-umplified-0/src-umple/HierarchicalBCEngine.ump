namespace weka.gui.graphvisualizer;

class MyListNode
{
 depend java.awt.GridBagConstraints;
 depend java.awt.GridBagLayout;
 depend java.awt.event.ActionEvent;
 depend java.awt.event.ActionListener;
 depend java.util.ArrayList;
 depend javax.swing.BorderFactory;
 depend javax.swing.ButtonGroup;
 depend javax.swing.JCheckBox;
 depend javax.swing.JPanel;
 depend javax.swing.JProgressBar;
 depend javax.swing.JRadioButton;
/** 
 * FastVector containing nodes and edges 
 */
protected ArrayList<GraphNode> m_nodes;

protected ArrayList<GraphEdge> m_edges;

/** 
 * FastVector containing listeners for layoutCompleteEvent generated by this LayoutEngine
 */
protected ArrayList<LayoutCompleteEventListener> layoutCompleteListeners;

/** 
 * Interconnection matrix for the graph 
 */
protected int graphMatrix[][];

/** 
 * Array containing the indices of nodes in each level. The nodeLevels.length is equal to the number of levels
 */
protected int nodeLevels[][];

/** 
 * The nodeWidth and nodeHeight 
 */
protected int m_nodeWidth, m_nodeHeight;

protected JRadioButton m_jRbNaiveLayout;

protected JRadioButton m_jRbPriorityLayout;

protected JRadioButton m_jRbTopdown;

protected JRadioButton m_jRbBottomup;

/** 
 * controls edge concentration by concentrating multilple singular dummy child nodes into one plural dummy child node
 */
protected JCheckBox m_jCbEdgeConcentration;

/** 
 * The panel containing extra options, specific to this LayoutEngine, for greater control over layout of the graph
 */
protected JPanel m_controlsPanel;

/** 
 * The progress bar to show the progress of the layout process
 */
protected JProgressBar m_progress;

/** 
 * This tells the the LayoutGraph method if a completeReLayout should be performed when it is called.
 */
protected boolean m_completeReLayout=false;

/** 
 * This contains the original size of the nodes vector when it was passed in through the constructor, before adding all the dummy vertices
 */
private int origNodesSize;

int size;

MyListNode first=null;

MyListNode last=null;

int n;

MyListNode next, previous;

/** 
 * Constructor - takes in FastVectors of nodes and edges, and the initial width and height of a node
 */
public HierarchicalBCEngine(ArrayList<GraphNode> nodes,ArrayList<GraphEdge> edges,int nodeWidth,int nodeHeight){
  m_nodes=nodes;
  m_edges=edges;
  m_nodeWidth=nodeWidth;
  m_nodeHeight=nodeHeight;
  makeGUIPanel(false);
}

/** 
 * Constructor - takes in FastVectors of nodes and edges, the initial width and height of a node, and a boolean value to indicate if the edges should be concentrated.
 * @param nodes - FastVector containing all the nodes
 * @param edges - FastVector containing all the edges
 * @param nodeWidth - A node's allowed width
 * @param nodeHeight - A node's allowed height
 * @param edgeConcentration - True: if want to concentrate edges, False:otherwise
 */
public HierarchicalBCEngine(ArrayList<GraphNode> nodes,ArrayList<GraphEdge> edges,int nodeWidth,int nodeHeight,boolean edgeConcentration){
  m_nodes=nodes;
  m_edges=edges;
  m_nodeWidth=nodeWidth;
  m_nodeHeight=nodeHeight;
  makeGUIPanel(edgeConcentration);
}

/** 
 * SimpleConstructor If we want to instantiate the class first, and if information for nodes and edges is not available. However, we would have to manually provide all the information later on by calling setNodesEdges and setNodeSize methods
 */
public HierarchicalBCEngine(){
}

/** 
 * This methods makes the gui extra controls panel "m_controlsPanel"
 */
protected void makeGUIPanel(boolean edgeConc){
  m_jRbNaiveLayout=new JRadioButton("Naive Layout");
  m_jRbPriorityLayout=new JRadioButton("Priority Layout");
  ButtonGroup bg=new ButtonGroup();
  bg.add(m_jRbNaiveLayout);
  bg.add(m_jRbPriorityLayout);
  m_jRbPriorityLayout.setSelected(true);
  ActionListener a=new ActionListener(){
    @Override public void actionPerformed(    ActionEvent ae){
      m_completeReLayout=true;
    }
  }
;
  m_jRbTopdown=new JRadioButton("Top Down");
  m_jRbBottomup=new JRadioButton("Bottom Up");
  m_jRbTopdown.addActionListener(a);
  m_jRbBottomup.addActionListener(a);
  bg=new ButtonGroup();
  bg.add(m_jRbTopdown);
  bg.add(m_jRbBottomup);
  m_jRbBottomup.setSelected(true);
  m_jCbEdgeConcentration=new JCheckBox("With Edge Concentration",edgeConc);
  m_jCbEdgeConcentration.setSelected(edgeConc);
  m_jCbEdgeConcentration.addActionListener(a);
  JPanel jp1=new JPanel(new GridBagLayout());
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.gridwidth=GridBagConstraints.REMAINDER;
  gbc.anchor=GridBagConstraints.NORTHWEST;
  gbc.weightx=1;
  gbc.fill=GridBagConstraints.HORIZONTAL;
  jp1.add(m_jRbNaiveLayout,gbc);
  jp1.add(m_jRbPriorityLayout,gbc);
  jp1.setBorder(BorderFactory.createTitledBorder("Layout Type"));
  JPanel jp2=new JPanel(new GridBagLayout());
  jp2.add(m_jRbTopdown,gbc);
  jp2.add(m_jRbBottomup,gbc);
  jp2.setBorder(BorderFactory.createTitledBorder("Layout Method"));
  m_progress=new JProgressBar(0,11);
  m_progress.setBorderPainted(false);
  m_progress.setStringPainted(true);
  m_progress.setString("");
  m_progress.setValue(0);
  m_controlsPanel=new JPanel(new GridBagLayout());
  m_controlsPanel.add(jp1,gbc);
  m_controlsPanel.add(jp2,gbc);
  m_controlsPanel.add(m_jCbEdgeConcentration,gbc);
}

@Override public void actionPerformed(ActionEvent ae){
  m_completeReLayout=true;
}

/** 
 * give access to set of graph nodes 
 */
@Override public ArrayList<GraphNode> getNodes(){
  return m_nodes;
}

/** 
 * This method returns a handle to the extra controls panel, so that the visualizing class can add it to some of it's own gui panel.
 */
@Override public JPanel getControlPanel(){
  return m_controlsPanel;
}

/** 
 * Returns a handle to the progressBar of this LayoutEngine.
 */
@Override public JProgressBar getProgressBar(){
  return m_progress;
}

/** 
 * Sets the nodes and edges for this LayoutEngine. Must be used if the class created by simple HierarchicalBCEngine() constructor.
 * @param nodes - FastVector containing all the nodes
 * @param edges - FastVector containing all the edges
 */
@Override public void setNodesEdges(ArrayList<GraphNode> nodes,ArrayList<GraphEdge> edges){
  m_nodes=nodes;
  m_edges=edges;
}

/** 
 * Sets the size of a node. This method must be used if the class created by simple HierarchicalBCEngine() constructor.
 * @param nodeWidth - A node's allowed width
 * @param nodeHeight - A node's allowed height
 */
@Override public void setNodeSize(int nodeWidth,int nodeHeight){
  m_nodeWidth=nodeWidth;
  m_nodeHeight=nodeHeight;
}

/** 
 * Method to add a LayoutCompleteEventListener
 * @param l - Listener to receive the LayoutCompleteEvent by this class.
 */
@Override public void addLayoutCompleteEventListener(LayoutCompleteEventListener l){
  if (layoutCompleteListeners == null) {
    layoutCompleteListeners=new ArrayList<LayoutCompleteEventListener>();
  }
  layoutCompleteListeners.add(l);
}

/** 
 * Method to remove a LayoutCompleteEventListener.
 * @param e - The LayoutCompleteEventListener to remove.
 */
@Override public void removeLayoutCompleteEventListener(LayoutCompleteEventListener e){
  if (layoutCompleteListeners != null) {
    LayoutCompleteEventListener l;
    for (int i=0; i < layoutCompleteListeners.size(); i++) {
      l=layoutCompleteListeners.get(i);
      if (l == e) {
        layoutCompleteListeners.remove(i);
        return;
      }
    }
    System.err.println("layoutCompleteListener to be remove not present");
  }
 else {
    System.err.println("layoutCompleteListener to be remove not present");
  }
}

/** 
 * Fires a LayoutCompleteEvent.
 * @param e - The LayoutCompleteEvent to fire
 */
@Override public void fireLayoutCompleteEvent(LayoutCompleteEvent e){
  if (layoutCompleteListeners != null && layoutCompleteListeners.size() != 0) {
    LayoutCompleteEventListener l;
    for (int i=0; i < layoutCompleteListeners.size(); i++) {
      l=layoutCompleteListeners.get(i);
      l.layoutCompleted(e);
    }
  }
}

/** 
 * This method does a complete layout of the graph which includes removing cycles, assigning levels to nodes, reducing edge crossings and laying out the vertices horizontally for better visibility. The removing of cycles and assignment of levels is only performed if hasn't been performed earlier or if some layout option has been changed and it is necessary to do so. It is necessary to do so, if the user selects/deselects edge concentration or topdown/bottomup options. <p> The layout is performed in a separate thread and the progress bar of the class is updated for each of the steps as the process continues.
 */
@Override public void layoutGraph(){
  if (m_nodes == null || m_edges == null) {
    return;
  }
  Thread th=new Thread(){
    @Override public void run(){
      m_progress.setBorderPainted(true);
      if (nodeLevels == null) {
        makeProperHierarchy();
      }
 else       if (m_completeReLayout == true) {
        clearTemps_and_EdgesFromNodes();
        makeProperHierarchy();
        m_completeReLayout=false;
      }
      if (m_jRbTopdown.isSelected()) {
        int crossbefore=crossings(nodeLevels), crossafter=0, i=0;
        do {
          m_progress.setValue(i + 4);
          m_progress.setString("Minimizing Crossings: Pass" + (i + 1));
          if (i != 0) {
            crossbefore=crossafter;
          }
          nodeLevels=minimizeCrossings(false,nodeLevels);
          crossafter=crossings(nodeLevels);
          i++;
        }
 while (crossafter < crossbefore && i < 6);
      }
 else {
        int crossbefore=crossings(nodeLevels), crossafter=0, i=0;
        do {
          m_progress.setValue(i + 4);
          m_progress.setString("Minimizing Crossings: Pass" + (i + 1));
          if (i != 0) {
            crossbefore=crossafter;
          }
          nodeLevels=minimizeCrossings(true,nodeLevels);
          crossafter=crossings(nodeLevels);
          i++;
        }
 while (crossafter < crossbefore && i < 6);
      }
      m_progress.setValue(10);
      m_progress.setString("Laying out vertices");
      if (m_jRbNaiveLayout.isSelected()) {
        naiveLayout();
      }
 else {
        priorityLayout1();
      }
      m_progress.setValue(11);
      m_progress.setString("Layout Complete");
      m_progress.repaint();
      fireLayoutCompleteEvent(new LayoutCompleteEvent(this));
      m_progress.setValue(0);
      m_progress.setString("");
      m_progress.setBorderPainted(false);
    }
  }
;
  th.start();
}

@Override public void run(){
  m_progress.setBorderPainted(true);
  if (nodeLevels == null) {
    makeProperHierarchy();
  }
 else   if (m_completeReLayout == true) {
    clearTemps_and_EdgesFromNodes();
    makeProperHierarchy();
    m_completeReLayout=false;
  }
  if (m_jRbTopdown.isSelected()) {
    int crossbefore=crossings(nodeLevels), crossafter=0, i=0;
    do {
      m_progress.setValue(i + 4);
      m_progress.setString("Minimizing Crossings: Pass" + (i + 1));
      if (i != 0) {
        crossbefore=crossafter;
      }
      nodeLevels=minimizeCrossings(false,nodeLevels);
      crossafter=crossings(nodeLevels);
      i++;
    }
 while (crossafter < crossbefore && i < 6);
  }
 else {
    int crossbefore=crossings(nodeLevels), crossafter=0, i=0;
    do {
      m_progress.setValue(i + 4);
      m_progress.setString("Minimizing Crossings: Pass" + (i + 1));
      if (i != 0) {
        crossbefore=crossafter;
      }
      nodeLevels=minimizeCrossings(true,nodeLevels);
      crossafter=crossings(nodeLevels);
      i++;
    }
 while (crossafter < crossbefore && i < 6);
  }
  m_progress.setValue(10);
  m_progress.setString("Laying out vertices");
  if (m_jRbNaiveLayout.isSelected()) {
    naiveLayout();
  }
 else {
    priorityLayout1();
  }
  m_progress.setValue(11);
  m_progress.setString("Layout Complete");
  m_progress.repaint();
  fireLayoutCompleteEvent(new LayoutCompleteEvent(this));
  m_progress.setValue(0);
  m_progress.setString("");
  m_progress.setBorderPainted(false);
}

/** 
 * This method removes the temporary nodes that were added to fill in the gaps, and removes all edges from all nodes in their edges[][] array
 */
protected void clearTemps_and_EdgesFromNodes(){
  int curSize=m_nodes.size();
  for (int i=origNodesSize; i < curSize; i++) {
    m_nodes.remove(origNodesSize);
  }
  for (int j=0; j < m_nodes.size(); j++) {
    m_nodes.get(j).edges=null;
  }
  nodeLevels=null;
}

/** 
 * This method makes the "graphMatrix" interconnection matrix for the graph given by m_nodes and m_edges vectors. The matix is used by other methods.
 */
protected void processGraph(){
  origNodesSize=m_nodes.size();
  graphMatrix=new int[m_nodes.size()][m_nodes.size()];
  for (int i=0; i < m_edges.size(); i++) {
    graphMatrix[m_edges.get(i).src][m_edges.get(i).dest]=m_edges.get(i).type;
  }
}

protected void makeProperHierarchy(){
  processGraph();
  m_progress.setValue(1);
  m_progress.setString("Removing Cycles");
  removeCycles();
  m_progress.setValue(2);
  m_progress.setString("Assigning levels to nodes");
  int nodesLevel[]=new int[m_nodes.size()];
  int depth=0;
  for (int i=0; i < graphMatrix.length; i++) {
    assignLevels(nodesLevel,depth,i,0);
  }
  for (int i=0; i < nodesLevel.length; i++) {
    if (nodesLevel[i] == 0) {
      int min=65536;
      for (int j=0; j < graphMatrix[i].length; j++) {
        if (graphMatrix[i][j] == DIRECTED) {
          if (min > nodesLevel[j]) {
            min=nodesLevel[j];
          }
        }
      }
      if (min != 65536 && min > 1) {
        nodesLevel[i]=min - 1;
      }
    }
  }
  int maxLevel=0;
  for (  int element : nodesLevel) {
    if (element > maxLevel) {
      maxLevel=element;
    }
  }
  int levelCounts[]=new int[maxLevel + 1];
  for (int i=0; i < nodesLevel.length; i++) {
    levelCounts[nodesLevel[i]]++;
  }
  int levelsCounter[]=new int[maxLevel + 1];
  nodeLevels=new int[maxLevel + 1][];
  for (int i=0; i < nodesLevel.length; i++) {
    if (nodeLevels[nodesLevel[i]] == null) {
      nodeLevels[nodesLevel[i]]=new int[levelCounts[nodesLevel[i]]];
    }
    nodeLevels[nodesLevel[i]][levelsCounter[nodesLevel[i]]++]=i;
  }
  m_progress.setValue(3);
  m_progress.setString("Removing gaps by adding dummy vertices");
  if (m_jCbEdgeConcentration.isSelected()) {
    removeGapsWithEdgeConcentration(nodesLevel);
  }
 else {
    removeGaps(nodesLevel);
  }
  for (int i=0; i < graphMatrix.length; i++) {
    GraphNode n=m_nodes.get(i);
    int sum=0;
    for (int j=0; j < graphMatrix[i].length; j++) {
      if (graphMatrix[i][j] != 0) {
        sum++;
      }
    }
    n.edges=new int[sum][2];
    for (int j=0, k=0; j < graphMatrix[i].length; j++) {
      if (graphMatrix[i][j] != 0) {
        n.edges[k][0]=j;
        n.edges[k][1]=graphMatrix[i][j];
        k++;
      }
    }
  }
}

/** 
 * This method removes gaps from the graph. It doesn't perform any concentration. It takes as an argument of int[] of length m_nodes.size() containing the level of each node.
 */
private void removeGaps(int nodesLevel[]){
  int temp=m_nodes.size();
  int temp2=graphMatrix[0].length, tempCnt=1;
  for (int n=0; n < temp; n++) {
    for (int i=0; i < temp2; i++) {
      int len=graphMatrix.length;
      if (graphMatrix[n][i] > 0) {
        if (nodesLevel[i] > nodesLevel[n] + 1) {
          int tempMatrix[][]=new int[graphMatrix.length + (nodesLevel[i] - nodesLevel[n] - 1)][graphMatrix.length + (nodesLevel[i] - nodesLevel[n] - 1)];
          int level=nodesLevel[n] + 1;
          copyMatrix(graphMatrix,tempMatrix);
          String s1=new String("S" + tempCnt++);
          m_nodes.add(new GraphNode(s1,s1,SINGULAR_DUMMY));
          int temp3[]=new int[nodeLevels[level].length + 1];
          System.arraycopy(nodeLevels[level],0,temp3,0,nodeLevels[level].length);
          temp3[temp3.length - 1]=m_nodes.size() - 1;
          nodeLevels[level]=temp3;
          level++;
          int k;
          for (k=len; k < len + nodesLevel[i] - nodesLevel[n] - 1 - 1; k++) {
            String s2=new String("S" + tempCnt);
            m_nodes.add(new GraphNode(s2,s2,SINGULAR_DUMMY));
            temp3=new int[nodeLevels[level].length + 1];
            System.arraycopy(nodeLevels[level],0,temp3,0,nodeLevels[level].length);
            temp3[temp3.length - 1]=m_nodes.size() - 1;
            nodeLevels[level++]=temp3;
            tempMatrix[k][k + 1]=tempMatrix[n][i];
            tempCnt++;
            if (k > len) {
              tempMatrix[k][k - 1]=-1 * tempMatrix[n][i];
            }
          }
          tempMatrix[k][i]=tempMatrix[n][i];
          tempMatrix[n][len]=tempMatrix[n][i];
          tempMatrix[len][n]=-1 * tempMatrix[n][i];
          tempMatrix[i][k]=-1 * tempMatrix[n][i];
          if (k > len) {
            tempMatrix[k][k - 1]=-1 * tempMatrix[n][i];
          }
          tempMatrix[n][i]=0;
          tempMatrix[i][n]=0;
          graphMatrix=tempMatrix;
        }
 else {
          graphMatrix[i][n]=-1 * graphMatrix[n][i];
        }
      }
    }
  }
}

/** 
 * This method removes gaps from the graph. It tries to minimise the number of edges by concentrating multiple dummy nodes from the same parent and on the same vertical level into one. It takes as an argument of int[] of length m_nodes.size() containing the level of each node.
 */
private void removeGapsWithEdgeConcentration(int nodesLevel[]){
  final int temp=m_nodes.size(), temp2=graphMatrix[0].length;
  int tempCnt=1;
  for (int n=0; n < temp; n++) {
    for (int i=0; i < temp2; i++) {
      if (graphMatrix[n][i] > 0) {
        if (nodesLevel[i] > nodesLevel[n] + 1) {
          int tempLevel=nodesLevel[n];
          boolean tempNodePresent=false;
          int k=temp;
          int tempnode=n;
          while (tempLevel < nodesLevel[i] - 1) {
            tempNodePresent=false;
            for (; k < graphMatrix.length; k++) {
              if (graphMatrix[tempnode][k] > 0) {
                tempNodePresent=true;
                break;
              }
            }
            if (tempNodePresent) {
              tempnode=k;
              k=k + 1;
              tempLevel++;
            }
 else {
              if (tempnode != n) {
                tempnode=k - 1;
              }
              break;
            }
          }
          if (m_nodes.get(tempnode).nodeType == SINGULAR_DUMMY) {
            m_nodes.get(tempnode).nodeType=PLURAL_DUMMY;
          }
          if (tempNodePresent) {
            graphMatrix[tempnode][i]=graphMatrix[n][i];
            graphMatrix[i][tempnode]=-graphMatrix[n][i];
            graphMatrix[n][i]=0;
            graphMatrix[i][n]=0;
            continue;
          }
          int len=graphMatrix.length;
          int tempMatrix[][]=new int[graphMatrix.length + (nodesLevel[i] - nodesLevel[tempnode] - 1)][graphMatrix.length + (nodesLevel[i] - nodesLevel[tempnode] - 1)];
          int level=nodesLevel[tempnode] + 1;
          copyMatrix(graphMatrix,tempMatrix);
          String s1=new String("S" + tempCnt++);
          m_nodes.add(new GraphNode(s1,s1,SINGULAR_DUMMY));
          int temp3[]=new int[nodeLevels[level].length + 1];
          System.arraycopy(nodeLevels[level],0,temp3,0,nodeLevels[level].length);
          temp3[temp3.length - 1]=m_nodes.size() - 1;
          nodeLevels[level]=temp3;
          temp3=new int[m_nodes.size() + 1];
          System.arraycopy(nodesLevel,0,temp3,0,nodesLevel.length);
          temp3[m_nodes.size() - 1]=level;
          nodesLevel=temp3;
          level++;
          int m;
          for (m=len; m < len + nodesLevel[i] - nodesLevel[tempnode] - 1 - 1; m++) {
            String s2=new String("S" + tempCnt++);
            m_nodes.add(new GraphNode(s2,s2,SINGULAR_DUMMY));
            temp3=new int[nodeLevels[level].length + 1];
            System.arraycopy(nodeLevels[level],0,temp3,0,nodeLevels[level].length);
            temp3[temp3.length - 1]=m_nodes.size() - 1;
            nodeLevels[level]=temp3;
            temp3=new int[m_nodes.size() + 1];
            System.arraycopy(nodesLevel,0,temp3,0,nodesLevel.length);
            temp3[m_nodes.size() - 1]=level;
            nodesLevel=temp3;
            level++;
            tempMatrix[m][m + 1]=tempMatrix[n][i];
            if (m > len) {
              tempMatrix[m][m - 1]=-1 * tempMatrix[n][i];
            }
          }
          tempMatrix[m][i]=tempMatrix[n][i];
          tempMatrix[tempnode][len]=tempMatrix[n][i];
          tempMatrix[len][tempnode]=-1 * tempMatrix[n][i];
          tempMatrix[i][m]=-1 * tempMatrix[n][i];
          if (m > len) {
            tempMatrix[m][m - 1]=-1 * tempMatrix[n][i];
          }
          tempMatrix[n][i]=0;
          tempMatrix[i][n]=0;
          graphMatrix=tempMatrix;
        }
 else {
          graphMatrix[i][n]=-1 * graphMatrix[n][i];
        }
      }
    }
  }
}

/** 
 * Returns the index of an element in a level. Must never be called with the wrong element and the wrong level, will throw an exception otherwise. It takes as agrument the index of the element (in the m_nodes vector) and the level it is supposed to be in (as each level contains the indices of the nodes present in that level).
 */
private int indexOfElementInLevel(int element,int level[]) throws Exception {
  for (int i=0; i < level.length; i++) {
    if (level[i] == element) {
      return i;
    }
  }
  throw new Exception("Error. Didn't find element " + m_nodes.get(element).ID + " in level. Inspect code for "+ "weka.gui.graphvisualizer.HierarchicalBCEngine");
}

/** 
 * Computes the number of edge crossings in the whole graph Takes as an argument levels of nodes. It is essentially the same algorithm provided in Universitat des Saarlandes technical report A03/94 by Georg Sander.
 */
protected int crossings(final int levels[][]){
  int sum=0;
  for (int i=0; i < levels.length - 1; i++) {
    MyList upper=new MyList(), lower=new MyList();
    MyListNode lastOcrnce[]=new MyListNode[m_nodes.size()];
    int edgeOcrnce[]=new int[m_nodes.size()];
    for (int j=0, uidx=0, lidx=0; j < (levels[i].length + levels[i + 1].length); j++) {
      if ((j % 2 == 0 && uidx < levels[i].length) || lidx >= levels[i + 1].length) {
        int k1=0, k2=0, k3=0;
        GraphNode n=m_nodes.get(levels[i][uidx]);
        if (lastOcrnce[levels[i][uidx]] != null) {
          MyListNode temp=new MyListNode(-1);
          temp.next=upper.first;
          try {
            do {
              temp=temp.next;
              if (levels[i][uidx] == temp.n) {
                k1=k1 + 1;
                k3=k3 + k2;
                upper.remove(temp);
              }
 else {
                k2=k2 + 1;
              }
            }
 while (temp != lastOcrnce[levels[i][uidx]]);
          }
 catch (          NullPointerException ex) {
            System.out.println("levels[i][uidx]: " + levels[i][uidx] + " which is: "+ m_nodes.get(levels[i][uidx]).ID+ " temp: "+ temp+ " upper.first: "+ upper.first);
            ex.printStackTrace();
            System.exit(-1);
          }
          lastOcrnce[levels[i][uidx]]=null;
          sum=sum + k1 * lower.size() + k3;
        }
        for (int k=0; k < n.edges.length; k++) {
          if (n.edges[k][1] > 0) {
            try {
              if (indexOfElementInLevel(n.edges[k][0],levels[i + 1]) >= uidx) {
                edgeOcrnce[n.edges[k][0]]=1;
              }
            }
 catch (            Exception ex) {
              ex.printStackTrace();
            }
          }
        }
        for (int k=0; k < levels[i + 1].length; k++) {
          if (edgeOcrnce[levels[i + 1][k]] == 1) {
            MyListNode temp=new MyListNode(levels[i + 1][k]);
            lower.add(temp);
            lastOcrnce[levels[i + 1][k]]=temp;
            edgeOcrnce[levels[i + 1][k]]=0;
          }
        }
        uidx++;
      }
 else {
        int k1=0, k2=0, k3=0;
        GraphNode n=m_nodes.get(levels[i + 1][lidx]);
        if (lastOcrnce[levels[i + 1][lidx]] != null) {
          MyListNode temp=new MyListNode(-1);
          temp.next=lower.first;
          try {
            do {
              temp=temp.next;
              if (levels[i + 1][lidx] == temp.n) {
                k1=k1 + 1;
                k3=k3 + k2;
                lower.remove(temp);
              }
 else {
                k2=k2 + 1;
              }
            }
 while (temp != lastOcrnce[levels[i + 1][lidx]]);
          }
 catch (          NullPointerException ex) {
            System.out.print("levels[i+1][lidx]: " + levels[i + 1][lidx] + " which is: "+ m_nodes.get(levels[i + 1][lidx]).ID+ " temp: "+ temp);
            System.out.println(" lower.first: " + lower.first);
            ex.printStackTrace();
            System.exit(-1);
          }
          lastOcrnce[levels[i + 1][lidx]]=null;
          sum=sum + k1 * upper.size() + k3;
        }
        for (int k=0; k < n.edges.length; k++) {
          if (n.edges[k][1] < 0) {
            try {
              if (indexOfElementInLevel(n.edges[k][0],levels[i]) > lidx) {
                edgeOcrnce[n.edges[k][0]]=1;
              }
            }
 catch (            Exception ex) {
              ex.printStackTrace();
            }
          }
        }
        for (int k=0; k < levels[i].length; k++) {
          if (edgeOcrnce[levels[i][k]] == 1) {
            MyListNode temp=new MyListNode(levels[i][k]);
            upper.add(temp);
            lastOcrnce[levels[i][k]]=temp;
            edgeOcrnce[levels[i][k]]=0;
          }
        }
        lidx++;
      }
    }
  }
  return sum;
}

/** 
 * The following two methods remove cycles from the graph.
 */
protected void removeCycles(){
  int visited[]=new int[m_nodes.size()];
  for (int i=0; i < graphMatrix.length; i++) {
    if (visited[i] == 0) {
      removeCycles2(i,visited);
      visited[i]=1;
    }
  }
}

/** 
 * This method should not be called directly. It should be called only from to call removeCycles()
 */
private void removeCycles2(int nindex,int visited[]){
  visited[nindex]=2;
  for (int i=0; i < graphMatrix[nindex].length; i++) {
    if (graphMatrix[nindex][i] == DIRECTED) {
      if (visited[i] == 0) {
        removeCycles2(i,visited);
        visited[i]=1;
      }
 else       if (visited[i] == 2) {
        if (nindex == i) {
          graphMatrix[nindex][i]=0;
        }
 else         if (graphMatrix[i][nindex] == DIRECTED) {
          graphMatrix[i][nindex]=DOUBLE;
          graphMatrix[nindex][i]=-DOUBLE;
        }
 else {
          graphMatrix[i][nindex]=REVERSED;
          graphMatrix[nindex][i]=-REVERSED;
        }
      }
    }
  }
}

/** 
 * This method assigns a vertical level to each node. See makeProperHierarchy() to see how to use it.
 */
protected void assignLevels(int levels[],int depth,int i,int j){
  if (i >= graphMatrix.length) {
    return;
  }
 else   if (j >= graphMatrix[i].length) {
    return;
  }
  if (graphMatrix[i][j] <= 0) {
    assignLevels(levels,depth,i,++j);
  }
 else   if (graphMatrix[i][j] == DIRECTED || graphMatrix[i][j] == DOUBLE) {
    if (depth + 1 > levels[j]) {
      levels[j]=depth + 1;
      assignLevels(levels,depth + 1,j,0);
    }
    assignLevels(levels,depth,i,++j);
  }
}

/** 
 * This method minimizes the number of edge crossings using the BaryCenter heuristics given by Sugiyama et al. 1981 This method processes the graph topdown if reversed is false, otherwise it does bottomup.
 */
private int[][] minimizeCrossings(boolean reversed,int nodeLevels[][]){
  if (reversed == false) {
    for (int times=0; times < 1; times++) {
      int tempLevels[][]=new int[nodeLevels.length][];
      copy2DArray(nodeLevels,tempLevels);
      for (int i=0; i < nodeLevels.length - 1; i++) {
        phaseID(i,tempLevels);
      }
      if (crossings(tempLevels) < crossings(nodeLevels)) {
        nodeLevels=tempLevels;
      }
      tempLevels=new int[nodeLevels.length][];
      copy2DArray(nodeLevels,tempLevels);
      for (int i=nodeLevels.length - 2; i >= 0; i--) {
        phaseIU(i,tempLevels);
      }
      if (crossings(tempLevels) < crossings(nodeLevels)) {
        nodeLevels=tempLevels;
      }
      tempLevels=new int[nodeLevels.length][];
      copy2DArray(nodeLevels,tempLevels);
      for (int i=0; i < nodeLevels.length - 1; i++) {
        phaseIID(i,tempLevels);
      }
      if (crossings(tempLevels) < crossings(nodeLevels)) {
        nodeLevels=tempLevels;
      }
      tempLevels=new int[nodeLevels.length][];
      copy2DArray(nodeLevels,tempLevels);
      for (int i=nodeLevels.length - 2; i >= 0; i--) {
        phaseIIU(i,tempLevels);
      }
      if (crossings(tempLevels) < crossings(nodeLevels)) {
        nodeLevels=tempLevels;
      }
    }
    return nodeLevels;
  }
 else {
    for (int times=0; times < 1; times++) {
      int tempLevels[][]=new int[nodeLevels.length][];
      copy2DArray(nodeLevels,tempLevels);
      for (int i=nodeLevels.length - 2; i >= 0; i--) {
        phaseIU(i,tempLevels);
      }
      if (crossings(tempLevels) < crossings(nodeLevels)) {
        nodeLevels=tempLevels;
      }
      tempLevels=new int[nodeLevels.length][];
      copy2DArray(nodeLevels,tempLevels);
      for (int i=0; i < nodeLevels.length - 1; i++) {
        phaseID(i,tempLevels);
      }
      if (crossings(tempLevels) < crossings(nodeLevels)) {
        nodeLevels=tempLevels;
      }
      tempLevels=new int[nodeLevels.length][];
      copy2DArray(nodeLevels,tempLevels);
      for (int i=nodeLevels.length - 2; i >= 0; i--) {
        phaseIIU(i,tempLevels);
      }
      if (crossings(tempLevels) < crossings(nodeLevels)) {
        nodeLevels=tempLevels;
      }
      tempLevels=new int[nodeLevels.length][];
      copy2DArray(nodeLevels,tempLevels);
      for (int i=0; i < nodeLevels.length - 1; i++) {
        phaseIID(i,tempLevels);
      }
      if (crossings(tempLevels) < crossings(nodeLevels)) {
        nodeLevels=tempLevels;
      }
    }
    return nodeLevels;
  }
}

/** 
 * See Sugiyama et al. 1981 (full reference give at top) lindex is the index of the level we want to process. In this method we'll sort the vertices at the level one below lindex according to their UP-barycenters (or column barycenters).
 */
protected void phaseID(final int lindex,final int levels[][]){
  float colBC[];
  colBC=calcColBC(lindex,levels);
  isort(levels[lindex + 1],colBC);
}

/** 
 * See Sugiyama et al. 1981 (full reference give at top) lindex is the index of the level we want to process. In this method we'll sort the vertices at the level lindex according to their DOWN-barycenters (or row barycenters).
 */
public void phaseIU(final int lindex,final int levels[][]){
  float rowBC[];
  rowBC=calcRowBC(lindex,levels);
  isort(levels[lindex],rowBC);
}

/** 
 * See Sugiyama et al. 1981 (full reference give at top)
 */
public void phaseIID(final int lindex,final int levels[][]){
  float colBC[];
  colBC=calcColBC(lindex,levels);
  for (int i=0; i < colBC.length - 1; i++) {
    if (colBC[i] == colBC[i + 1]) {
      int tempLevels[][]=new int[levels.length][];
      copy2DArray(levels,tempLevels);
      int node1=levels[lindex + 1][i];
      int node2=levels[lindex + 1][i + 1];
      levels[lindex + 1][i + 1]=node1;
      levels[lindex + 1][i]=node2;
      for (int k=lindex + 1; k < levels.length - 1; k++) {
        phaseID(k,levels);
      }
      if (crossings(levels) <= crossings(tempLevels)) {
        copy2DArray(levels,tempLevels);
      }
 else {
        copy2DArray(tempLevels,levels);
        levels[lindex + 1][i + 1]=node1;
        levels[lindex + 1][i]=node2;
      }
      for (int k=levels.length - 2; k >= 0; k--) {
        phaseIU(k,levels);
      }
      if (crossings(tempLevels) < crossings(levels)) {
        copy2DArray(tempLevels,levels);
      }
    }
  }
}

/** 
 * See Sugiyama et al. 1981 (full reference give at top)
 */
public void phaseIIU(final int lindex,final int levels[][]){
  float rowBC[];
  rowBC=calcRowBC(lindex,levels);
  for (int i=0; i < rowBC.length - 1; i++) {
    if (rowBC[i] == rowBC[i + 1]) {
      int tempLevels[][]=new int[levels.length][];
      copy2DArray(levels,tempLevels);
      int node1=levels[lindex][i];
      int node2=levels[lindex][i + 1];
      levels[lindex][i + 1]=node1;
      levels[lindex][i]=node2;
      for (int k=lindex - 1; k >= 0; k--) {
        phaseIU(k,levels);
      }
      if (crossings(levels) <= crossings(tempLevels)) {
        copy2DArray(levels,tempLevels);
      }
 else {
        copy2DArray(tempLevels,levels);
        levels[lindex][i + 1]=node1;
        levels[lindex][i]=node2;
      }
      for (int k=0; k < levels.length - 1; k++) {
        phaseID(k,levels);
      }
      if (crossings(tempLevels) <= crossings(levels)) {
        copy2DArray(tempLevels,levels);
      }
    }
  }
}

/** 
 * See Sugiyama et al. 1981 (full reference give at top)
 */
protected float[] calcRowBC(final int lindex,final int levels[][]){
  float rowBC[]=new float[levels[lindex].length];
  GraphNode n;
  for (int i=0; i < levels[lindex].length; i++) {
    int sum=0;
    n=m_nodes.get(levels[lindex][i]);
    for (    int[] edge : n.edges) {
      if (edge[1] > 0) {
        sum++;
        try {
          rowBC[i]=rowBC[i] + indexOfElementInLevel(edge[0],levels[lindex + 1]) + 1;
        }
 catch (        Exception ex) {
          return null;
        }
      }
    }
    if (rowBC[i] != 0) {
      rowBC[i]=rowBC[i] / sum;
    }
  }
  return rowBC;
}

/** 
 * See Sugiyama et al. 1981 (full reference give at top)
 */
protected float[] calcColBC(final int lindex,final int levels[][]){
  float colBC[]=new float[levels[lindex + 1].length];
  GraphNode n;
  for (int i=0; i < levels[lindex + 1].length; i++) {
    int sum=0;
    n=m_nodes.get(levels[lindex + 1][i]);
    for (    int[] edge : n.edges) {
      if (edge[1] < 1) {
        sum++;
        try {
          colBC[i]=colBC[i] + indexOfElementInLevel(edge[0],levels[lindex]) + 1;
        }
 catch (        Exception ex) {
          return null;
        }
      }
    }
    if (colBC[i] != 0) {
      colBC[i]=colBC[i] / sum;
    }
  }
  return colBC;
}

/** 
 * Prints out the interconnection matrix at each level. See Sugiyama et al. 1981 (full reference give at top)
 */
protected void printMatrices(final int levels[][]){
  int i=0;
  for (i=0; i < levels.length - 1; i++) {
    float rowBC[]=null;
    float colBC[]=null;
    try {
      rowBC=calcRowBC(i,levels);
      colBC=calcColBC(i,levels);
    }
 catch (    NullPointerException ne) {
      System.out.println("i: " + i + " levels.length: "+ levels.length);
      ne.printStackTrace();
      return;
    }
    System.out.print("\nM" + (i + 1) + "\t");
    for (int j=0; j < levels[i + 1].length; j++) {
      System.out.print(m_nodes.get(levels[i + 1][j]).ID + " ");
    }
    System.out.println("");
    for (int j=0; j < levels[i].length; j++) {
      System.out.print(m_nodes.get(levels[i][j]).ID + "\t");
      for (int k=0; k < levels[i + 1].length; k++) {
        System.out.print(graphMatrix[levels[i][j]][levels[i + 1][k]] + " ");
      }
      System.out.println(rowBC[j]);
    }
    System.out.print("\t");
    for (int k=0; k < levels[i + 1].length; k++) {
      System.out.print(colBC[k] + " ");
    }
  }
  System.out.println("\nAt the end i: " + i + " levels.length: "+ levels.length);
}

/** 
 * This methods sorts the vertices in level[] according to their barycenters in BC[], using insertion sort. It, however, doesn't touch the vertices with barycenter equal to zero.
 */
protected static void isort(int level[],float BC[]){
  float temp;
  int temp2;
  for (int i=0; i < BC.length - 1; i++) {
    int j=i;
    temp=BC[j + 1];
    temp2=level[j + 1];
    if (temp == 0) {
      continue;
    }
    int prej=j + 1;
    while (j > -1 && (temp < BC[j] || BC[j] == 0)) {
      if (BC[j] == 0) {
        j--;
        continue;
      }
 else {
        BC[prej]=BC[j];
        level[prej]=level[j];
        prej=j;
        j--;
      }
    }
    BC[prej]=temp;
    level[prej]=temp2;
  }
}

/** 
 * Copies one Matrix of type int[][] to another.
 */
protected void copyMatrix(int from[][],int to[][]){
  for (int i=0; i < from.length; i++) {
    for (int j=0; j < from[i].length; j++) {
      to[i][j]=from[i][j];
    }
  }
}

/** 
 * Copies one array of type int[][] to another.
 */
protected void copy2DArray(int from[][],int to[][]){
  for (int i=0; i < from.length; i++) {
    to[i]=new int[from[i].length];
    System.arraycopy(from[i],0,to[i],0,from[i].length);
  }
}

/** 
 * This method lays out the vertices horizontally, in each level. It simply assings an x value to a vertex according to its index in the level.
 */
protected void naiveLayout(){
  if (nodeLevels == null) {
    makeProperHierarchy();
  }
  for (int i=0, temp=0; i < nodeLevels.length; i++) {
    for (int j=0; j < nodeLevels[i].length; j++) {
      temp=nodeLevels[i][j];
      GraphNode n=m_nodes.get(temp);
      n.x=j * m_nodeWidth;
      n.y=i * 3 * m_nodeHeight;
    }
  }
}

protected int uConnectivity(int lindex,int eindex){
  int n=0;
  for (int i=0; i < nodeLevels[lindex - 1].length; i++) {
    if (graphMatrix[nodeLevels[lindex - 1][i]][nodeLevels[lindex][eindex]] > 0) {
      n++;
    }
  }
  return n;
}

protected int lConnectivity(int lindex,int eindex){
  int n=0;
  for (int i=0; i < nodeLevels[lindex + 1].length; i++) {
    if (graphMatrix[nodeLevels[lindex][eindex]][nodeLevels[lindex + 1][i]] > 0) {
      n++;
    }
  }
  return n;
}

protected int uBCenter(int lindex,int eindex,int horPositions[]){
  int sum=0;
  for (int i=0; i < nodeLevels[lindex - 1].length; i++) {
    if (graphMatrix[nodeLevels[lindex - 1][i]][nodeLevels[lindex][eindex]] > 0) {
      sum=sum + (horPositions[nodeLevels[lindex - 1][i]]);
    }
  }
  if (sum != 0) {
    sum=sum / uConnectivity(lindex,eindex);
  }
  return sum;
}

protected int lBCenter(int lindex,int eindex,int horPositions[]){
  int sum=0;
  for (int i=0; i < nodeLevels[lindex + 1].length; i++) {
    if (graphMatrix[nodeLevels[lindex][eindex]][nodeLevels[lindex + 1][i]] > 0) {
      sum=sum + (horPositions[nodeLevels[lindex + 1][i]]);
    }
  }
  if (sum != 0) {
    sum=sum / lConnectivity(lindex,eindex);
  }
  return sum;
}

/** 
 * This method lays out the vertices horizontally, in each level. See Sugiyama et al. 1981 for full reference.
 */
protected void priorityLayout1(){
  int[] horPositions=new int[m_nodes.size()];
  int maxCount=0;
  for (int i=0; i < nodeLevels.length; i++) {
    int count=0;
    for (int j=0; j < nodeLevels[i].length; j++) {
      horPositions[nodeLevels[i][j]]=j;
      count++;
    }
    if (count > maxCount) {
      maxCount=count;
    }
  }
  int priorities[], BC[];
  for (int i=1; i < nodeLevels.length; i++) {
    priorities=new int[nodeLevels[i].length];
    BC=new int[nodeLevels[i].length];
    for (int j=0; j < nodeLevels[i].length; j++) {
      if (m_nodes.get(nodeLevels[i][j]).ID.startsWith("S")) {
        priorities[j]=maxCount + 1;
      }
 else {
        priorities[j]=uConnectivity(i,j);
      }
      BC[j]=uBCenter(i,j,horPositions);
    }
    priorityLayout2(nodeLevels[i],priorities,BC,horPositions);
  }
  for (int i=nodeLevels.length - 2; i >= 0; i--) {
    priorities=new int[nodeLevels[i].length];
    BC=new int[nodeLevels[i].length];
    for (int j=0; j < nodeLevels[i].length; j++) {
      if (m_nodes.get(nodeLevels[i][j]).ID.startsWith("S")) {
        priorities[j]=maxCount + 1;
      }
 else {
        priorities[j]=lConnectivity(i,j);
      }
      BC[j]=lBCenter(i,j,horPositions);
    }
    priorityLayout2(nodeLevels[i],priorities,BC,horPositions);
  }
  for (int i=2; i < nodeLevels.length; i++) {
    priorities=new int[nodeLevels[i].length];
    BC=new int[nodeLevels[i].length];
    for (int j=0; j < nodeLevels[i].length; j++) {
      if (m_nodes.get(nodeLevels[i][j]).ID.startsWith("S")) {
        priorities[j]=maxCount + 1;
      }
 else {
        priorities[j]=uConnectivity(i,j);
      }
      BC[j]=uBCenter(i,j,horPositions);
    }
    priorityLayout2(nodeLevels[i],priorities,BC,horPositions);
  }
  int minPosition=horPositions[0];
  for (  int horPosition : horPositions) {
    if (horPosition < minPosition) {
      minPosition=horPosition;
    }
  }
  if (minPosition < 0) {
    minPosition=minPosition * -1;
    for (int i=0; i < horPositions.length; i++) {
      horPositions[i]+=minPosition;
    }
  }
  for (int i=0, temp=0; i < nodeLevels.length; i++) {
    for (int j=0; j < nodeLevels[i].length; j++) {
      temp=nodeLevels[i][j];
      GraphNode n=m_nodes.get(temp);
      n.x=horPositions[temp] * m_nodeWidth;
      n.y=i * 3 * m_nodeHeight;
    }
  }
}

/** 
 * This method is used by priorityLayout1(). It should not be called directly. This method does the actual moving of the vertices in each level based on their priorities and barycenters.
 */
private void priorityLayout2(int level[],int priorities[],int bCenters[],int horPositions[]){
  int descOrder[]=new int[priorities.length];
  descOrder[0]=0;
  for (int i=0; i < priorities.length - 1; i++) {
    int j=i;
    int temp=i + 1;
    while (j > -1 && priorities[descOrder[j]] < priorities[temp]) {
      descOrder[j + 1]=descOrder[j];
      j--;
    }
    j++;
    descOrder[j]=temp;
  }
  for (int k=0; k < descOrder.length; k++) {
    for (int i=0; i < descOrder.length; i++) {
      int leftCount=0, rightCount=0, leftNodes[], rightNodes[];
      for (int j=0; j < priorities.length; j++) {
        if (horPositions[level[descOrder[i]]] > horPositions[level[j]]) {
          leftCount++;
        }
 else         if (horPositions[level[descOrder[i]]] < horPositions[level[j]]) {
          rightCount++;
        }
      }
      leftNodes=new int[leftCount];
      rightNodes=new int[rightCount];
      for (int j=0, l=0, r=0; j < priorities.length; j++) {
        if (horPositions[level[descOrder[i]]] > horPositions[level[j]]) {
          leftNodes[l++]=j;
        }
 else         if (horPositions[level[descOrder[i]]] < horPositions[level[j]]) {
          rightNodes[r++]=j;
        }
      }
      while (Math.abs(horPositions[level[descOrder[i]]] - 1 - bCenters[descOrder[i]]) < Math.abs(horPositions[level[descOrder[i]]] - bCenters[descOrder[i]])) {
        int temp=horPositions[level[descOrder[i]]];
        boolean cantMove=false;
        for (int j=leftNodes.length - 1; j >= 0; j--) {
          if (temp - horPositions[level[leftNodes[j]]] > 1) {
            break;
          }
 else           if (priorities[descOrder[i]] <= priorities[leftNodes[j]]) {
            cantMove=true;
            break;
          }
 else {
            temp=horPositions[level[leftNodes[j]]];
          }
        }
        if (cantMove) {
          break;
        }
        temp=horPositions[level[descOrder[i]]] - 1;
        for (int j=leftNodes.length - 1; j >= 0; j--) {
          if (temp == horPositions[level[leftNodes[j]]]) {
            horPositions[level[leftNodes[j]]]=temp=horPositions[level[leftNodes[j]]] - 1;
          }
        }
        horPositions[level[descOrder[i]]]=horPositions[level[descOrder[i]]] - 1;
      }
      while (Math.abs(horPositions[level[descOrder[i]]] + 1 - bCenters[descOrder[i]]) < Math.abs(horPositions[level[descOrder[i]]] - bCenters[descOrder[i]])) {
        int temp=horPositions[level[descOrder[i]]];
        boolean cantMove=false;
        for (        int rightNode : rightNodes) {
          if (horPositions[level[rightNode]] - temp > 1) {
            break;
          }
 else           if (priorities[descOrder[i]] <= priorities[rightNode]) {
            cantMove=true;
            break;
          }
 else {
            temp=horPositions[level[rightNode]];
          }
        }
        if (cantMove) {
          break;
        }
        temp=horPositions[level[descOrder[i]]] + 1;
        for (int j=0; j < rightNodes.length; j++) {
          if (temp == horPositions[level[rightNodes[j]]]) {
            horPositions[level[rightNodes[j]]]=temp=horPositions[level[rightNodes[j]]] + 1;
          }
        }
        horPositions[level[descOrder[i]]]=horPositions[level[descOrder[i]]] + 1;
      }
    }
  }
}

public void add(MyListNode n){
  if (first == null) {
    first=last=n;
  }
 else   if (last.next == null) {
    last.next=n;
    last.next.previous=last;
    last=last.next;
  }
 else {
    System.err.println("Error shouldn't be in here. Check MyList code");
    size--;
  }
  size++;
}

public void remove(MyListNode n){
  if (n.previous != null) {
    n.previous.next=n.next;
  }
  if (n.next != null) {
    n.next.previous=n.previous;
  }
  if (last == n) {
    last=n.previous;
  }
  if (first == n) {
    first=n.next;
  }
  size--;
}

public int size(){
  return size;
}

public MyListNode(int i){
  n=i;
  next=null;
  previous=null;
}
}
