namespace weka.gui.treevisualizer;

class Ease
{
 depend java.util.Vector;
/** 
 * The space each row will take up. 
 */
private double m_yRatio;

/** 
 * An array that lists the groups and information about them. 
 */
private Group[] m_groups;

/** 
 * An array that lists the levels and information about them. 
 */
private Level[] m_levels;

/** 
 * The Number of groups the tree has 
 */
private int m_groupNum;

/** 
 * The number of levels the group tree has 
 */
private int m_levelNum;

/** 
 * The number for the group on the left of this level. 
 */
public int m_start;

/** 
 * The number for the group on the right of this level. 
 */
public int m_end;

/** 
 * The parent node of this group. 
 */
public Node m_p;

/** 
 * The group number for the parent of this group. 
 */
public int m_pg;

/** 
 * The gap size for the distance between the nodes in this group. 
 */
public double m_gap;

/** 
 * The leftmost position of this group. 
 */
public double m_left;

/** 
 * The rightmost position of this group. 
 */
public double m_right;

/** 
 * The size of this group. 
 */
public double m_size;

/** 
 * The start node of this group. 
 */
public int m_start;

/** 
 * The end node of this group. 
 */
public int m_end;

/** 
 * The number of the group on the left of the tangle. 
 */
public int m_place;

/** 
 * The distance they were tangled. 
 */
public double m_amount;

/** 
 * The level on which they were tangled. 
 */
public int m_lev;

/** 
 * The Funtion to call to have the nodes arranged.
 * @param r The top node of the tree to arrange.
 */
@Override public void place(Node r){
  m_groupNum=Node.getGCount(r,0);
  m_groups=new Group[m_groupNum];
  for (int noa=0; noa < m_groupNum; noa++) {
    m_groups[noa]=new Group();
    m_groups[noa].m_gap=3;
    m_groups[noa].m_start=-1;
  }
  groupBuild(r);
  m_levelNum=Node.getHeight(r,0);
  m_yRatio=1 / (double)(m_levelNum + 1);
  m_levels=new Level[m_levelNum];
  for (int noa=0; noa < m_levelNum; noa++) {
    m_levels[noa]=new Level();
  }
  r.setTop(m_yRatio);
  yPlacer();
  r.setCenter(0);
  xPlacer(0);
  untangle2();
  scaleByMax();
}

/** 
 * This will set initial places for the x coord of the nodes.
 * @param start The `number for the first group to start on (I think).
 */
private void xPlacer(int start){
  Node r;
  Edge e;
  if (m_groupNum > 0) {
    m_groups[0].m_p.setCenter(0);
    for (int noa=start; noa < m_groupNum; noa++) {
      int nob, alter=0;
      double c=m_groups[noa].m_gap;
      r=m_groups[noa].m_p;
      for (nob=0; (e=r.getChild(nob)) != null; nob++) {
        if (e.getTarget().getParent(0) == e) {
          e.getTarget().setCenter(nob * c);
        }
 else {
          alter++;
        }
      }
      m_groups[noa].m_size=(nob - 1 - alter) * c;
      xShift(noa);
    }
  }
}

/** 
 * This will shift a group of nodes to be aligned under their parent.
 * @param n The group number to shift
 */
private void xShift(int n){
  Edge e;
  Node r=m_groups[n].m_p;
  double h=m_groups[n].m_size / 2;
  double c=m_groups[n].m_p.getCenter();
  double m=c - h;
  m_groups[n].m_left=m;
  m_groups[n].m_right=c + h;
  for (int noa=0; (e=r.getChild(noa)) != null; noa++) {
    if (e.getTarget().getParent(0) == e) {
      e.getTarget().adjustCenter(m);
    }
  }
}

/** 
 * This scales all the x values to be between 0 and 1.
 */
private void scaleByMax(){
  double l_x=5000, h_x=-5000;
  for (int noa=0; noa < m_groupNum; noa++) {
    if (l_x > m_groups[noa].m_left) {
      l_x=m_groups[noa].m_left;
    }
    if (h_x < m_groups[noa].m_right) {
      h_x=m_groups[noa].m_right;
    }
  }
  Edge e;
  Node r, s;
  double m_scale=h_x - l_x + 1;
  if (m_groupNum > 0) {
    r=m_groups[0].m_p;
    r.setCenter((r.getCenter() - l_x) / m_scale);
    for (int noa=0; noa < m_groupNum; noa++) {
      r=m_groups[noa].m_p;
      for (int nob=0; (e=r.getChild(nob)) != null; nob++) {
        s=e.getTarget();
        if (s.getParent(0) == e) {
          s.setCenter((s.getCenter() - l_x) / m_scale);
        }
      }
    }
  }
}

/** 
 * This untangles the nodes so that they will will fall on the correct side of the other nodes along their row.
 */
private void untangle2(){
  Ease a;
  Edge e;
  Node r, nf=null, ns=null, mark;
  int l=0;
  int f, s, tf=0, ts=0, pf, ps;
  while ((a=overlap(l)) != null) {
    f=a.m_place;
    s=a.m_place + 1;
    while (f != s) {
      a.m_lev--;
      tf=f;
      ts=s;
      f=m_groups[f].m_pg;
      s=m_groups[s].m_pg;
    }
    l=a.m_lev;
    pf=0;
    ps=0;
    r=m_groups[f].m_p;
    mark=m_groups[tf].m_p;
    nf=null;
    ns=null;
    for (int noa=0; nf != mark; noa++) {
      pf++;
      nf=r.getChild(noa).getTarget();
    }
    mark=m_groups[ts].m_p;
    for (int noa=pf; ns != mark; noa++) {
      ps++;
      ns=r.getChild(noa).getTarget();
    }
    Vector<Double> o_pos=new Vector<Double>(20,10);
    for (int noa=0; (e=r.getChild(noa)) != null; noa++) {
      if (e.getTarget().getParent(0) == e) {
        Double tem=new Double(e.getTarget().getCenter());
        o_pos.addElement(tem);
      }
    }
    pf--;
    double inc=a.m_amount / ps;
    for (int noa=0; (e=r.getChild(noa)) != null; noa++) {
      ns=e.getTarget();
      if (ns.getParent(0) == e) {
        if (noa > pf + ps) {
          ns.adjustCenter(a.m_amount);
        }
 else         if (noa > pf) {
          ns.adjustCenter(inc * (noa - pf));
        }
      }
    }
    nf=r.getChild(0).getTarget();
    inc=ns.getCenter() - nf.getCenter();
    m_groups[f].m_size=inc;
    m_groups[f].m_left=r.getCenter() - inc / 2;
    m_groups[f].m_right=m_groups[f].m_left + inc;
    inc=m_groups[f].m_left - nf.getCenter();
    double shift;
    int g_num=0;
    for (int noa=0; (e=r.getChild(noa)) != null; noa++) {
      ns=e.getTarget();
      if (ns.getParent(0) == e) {
        ns.adjustCenter(inc);
        shift=ns.getCenter() - o_pos.elementAt(noa).doubleValue();
        if (ns.getChild(0) != null) {
          moveSubtree(m_groups[f].m_start + g_num,shift);
          g_num++;
        }
      }
    }
  }
}

/** 
 * This will recursively shift a sub there to be centered about a particular value.
 * @param n The first group in the sub tree.
 * @param o The point to start shifting the subtree.
 */
private void moveSubtree(int n,double o){
  Edge e;
  Node r=m_groups[n].m_p;
  for (int noa=0; (e=r.getChild(noa)) != null; noa++) {
    if (e.getTarget().getParent(0) == e) {
      e.getTarget().adjustCenter(o);
    }
  }
  m_groups[n].m_left+=o;
  m_groups[n].m_right+=o;
  if (m_groups[n].m_start != -1) {
    for (int noa=m_groups[n].m_start; noa <= m_groups[n].m_end; noa++) {
      moveSubtree(noa,o);
    }
  }
}

/** 
 * This will find an overlap and then return information about that overlap
 * @param l The level to start on.
 * @return null if there was no overlap , otherwise an object containing thegroup number that overlaps (only need one) how much they overlap by, and the level they overlap on.
 */
private Ease overlap(int l){
  Ease a=new Ease();
  for (int noa=l; noa < m_levelNum; noa++) {
    for (int nob=m_levels[noa].m_start; nob < m_levels[noa].m_end; nob++) {
      a.m_amount=m_groups[nob].m_right - m_groups[nob + 1].m_left + 2;
      if (a.m_amount >= 0) {
        a.m_amount++;
        a.m_lev=noa;
        a.m_place=nob;
        return a;
      }
    }
  }
  return null;
}

/** 
 * This function sets up the height of each node, and also fills the levels array with information about what the start and end groups on that level are.
 */
private void yPlacer(){
  double changer=m_yRatio;
  int lev_place=0;
  if (m_groupNum > 0) {
    m_groups[0].m_p.setTop(m_yRatio);
    m_levels[0].m_start=0;
    for (int noa=0; noa < m_groupNum; noa++) {
      if (m_groups[noa].m_p.getTop() != changer) {
        m_levels[lev_place].m_end=noa - 1;
        lev_place++;
        m_levels[lev_place].m_start=noa;
        changer=m_groups[noa].m_p.getTop();
      }
      nodeY(m_groups[noa].m_p);
    }
    m_levels[lev_place].m_end=m_groupNum - 1;
  }
}

/** 
 * This will set all of the children node of a particular node to their height.
 * @param r The parent node of the children to set their height.
 */
private void nodeY(Node r){
  Edge e;
  double h=r.getTop() + m_yRatio;
  for (int noa=0; (e=r.getChild(noa)) != null; noa++) {
    if (e.getTarget().getParent(0) == e) {
      e.getTarget().setTop(h);
      if (!e.getTarget().getVisible()) {
      }
    }
  }
}

/** 
 * This starts to create the information about the sibling groups. As more groups are created the for loop in this will check those groups for lower groups.
 * @param r The top node.
 */
private void groupBuild(Node r){
  if (m_groupNum > 0) {
    m_groupNum=0;
    m_groups[0].m_p=r;
    m_groupNum++;
    for (int noa=0; noa < m_groupNum; noa++) {
      groupFind(m_groups[noa].m_p,noa);
    }
  }
}

/** 
 * This is called to build the rest of the grouping information.
 * @param r The parent of the group.
 * @param pg The number for the parents group.
 */
private void groupFind(Node r,int pg){
  Edge e;
  boolean first=true;
  for (int noa=0; (e=r.getChild(noa)) != null; noa++) {
    if (e.getTarget().getParent(0) == e) {
      if (e.getTarget().getChild(0) != null && e.getTarget().getCVisible()) {
        if (first) {
          m_groups[pg].m_start=m_groupNum;
          first=false;
        }
        m_groups[pg].m_end=m_groupNum;
        m_groups[m_groupNum].m_p=e.getTarget();
        m_groups[m_groupNum].m_pg=pg;
        m_groupNum++;
      }
    }
  }
}
}
