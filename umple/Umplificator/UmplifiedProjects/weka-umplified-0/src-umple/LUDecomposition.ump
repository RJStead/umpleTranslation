namespace weka.core.matrix;

class LUDecomposition
{
  isA Serializable,RevisionHandler;
 depend weka.core.RevisionHandler;
 depend weka.core.RevisionUtils;
 depend java.io.Serializable;
/** 
 * for serialization 
 */
private static final long serialVersionUID=-2731022568037808629L;

/** 
 * Array for internal storage of decomposition.
 * @serial internal array storage.
 */
private double[][] LU;

/** 
 * Row and column dimensions, and pivot sign.
 * @serial column dimension.
 * @serial row dimension.
 * @serial pivot sign.
 */
private int m, n, pivsign;

/** 
 * Internal storage of pivot vector.
 * @serial pivot vector.
 */
private int[] piv;

/** 
 * LU Decomposition
 * @param A   Rectangular matrix
 */
public LUDecomposition(Matrix A){
  LU=A.getArrayCopy();
  m=A.getRowDimension();
  n=A.getColumnDimension();
  piv=new int[m];
  for (int i=0; i < m; i++) {
    piv[i]=i;
  }
  pivsign=1;
  double[] LUrowi;
  double[] LUcolj=new double[m];
  for (int j=0; j < n; j++) {
    for (int i=0; i < m; i++) {
      LUcolj[i]=LU[i][j];
    }
    for (int i=0; i < m; i++) {
      LUrowi=LU[i];
      int kmax=Math.min(i,j);
      double s=0.0;
      for (int k=0; k < kmax; k++) {
        s+=LUrowi[k] * LUcolj[k];
      }
      LUrowi[j]=LUcolj[i]-=s;
    }
    int p=j;
    for (int i=j + 1; i < m; i++) {
      if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
        p=i;
      }
    }
    if (p != j) {
      for (int k=0; k < n; k++) {
        double t=LU[p][k];
        LU[p][k]=LU[j][k];
        LU[j][k]=t;
      }
      int k=piv[p];
      piv[p]=piv[j];
      piv[j]=k;
      pivsign=-pivsign;
    }
    if (j < m & LU[j][j] != 0.0) {
      for (int i=j + 1; i < m; i++) {
        LU[i][j]/=LU[j][j];
      }
    }
  }
}

/** 
 * Is the matrix nonsingular?
 * @return     true if U, and hence A, is nonsingular.
 */
public boolean isNonsingular(){
  for (int j=0; j < n; j++) {
    if (LU[j][j] == 0)     return false;
  }
  return true;
}

/** 
 * Return lower triangular factor
 * @return     L
 */
public Matrix getL(){
  Matrix X=new Matrix(m,n);
  double[][] L=X.getArray();
  for (int i=0; i < m; i++) {
    for (int j=0; j < n; j++) {
      if (i > j) {
        L[i][j]=LU[i][j];
      }
 else       if (i == j) {
        L[i][j]=1.0;
      }
 else {
        L[i][j]=0.0;
      }
    }
  }
  return X;
}

/** 
 * Return upper triangular factor
 * @return     U
 */
public Matrix getU(){
  Matrix X=new Matrix(n,n);
  double[][] U=X.getArray();
  for (int i=0; i < n; i++) {
    for (int j=0; j < n; j++) {
      if (i <= j) {
        U[i][j]=LU[i][j];
      }
 else {
        U[i][j]=0.0;
      }
    }
  }
  return X;
}

/** 
 * Return pivot permutation vector
 * @return     piv
 */
public int[] getPivot(){
  int[] p=new int[m];
  for (int i=0; i < m; i++) {
    p[i]=piv[i];
  }
  return p;
}

/** 
 * Return pivot permutation vector as a one-dimensional double array
 * @return     (double) piv
 */
public double[] getDoublePivot(){
  double[] vals=new double[m];
  for (int i=0; i < m; i++) {
    vals[i]=(double)piv[i];
  }
  return vals;
}

/** 
 * Determinant
 * @return     det(A)
 * @exception IllegalArgumentException  Matrix must be square
 */
public double det(){
  if (m != n) {
    throw new IllegalArgumentException("Matrix must be square.");
  }
  double d=(double)pivsign;
  for (int j=0; j < n; j++) {
    d*=LU[j][j];
  }
  return d;
}

/** 
 * Solve A*X = B
 * @param B   A Matrix with as many rows as A and any number of columns.
 * @return     X so that L*U*X = B(piv,:)
 * @exception IllegalArgumentException Matrix row dimensions must agree.
 * @exception RuntimeException  Matrix is singular.
 */
public Matrix solve(Matrix B){
  if (B.getRowDimension() != m) {
    throw new IllegalArgumentException("Matrix row dimensions must agree.");
  }
  if (!this.isNonsingular()) {
    throw new RuntimeException("Matrix is singular.");
  }
  int nx=B.getColumnDimension();
  Matrix Xmat=B.getMatrix(piv,0,nx - 1);
  double[][] X=Xmat.getArray();
  for (int k=0; k < n; k++) {
    for (int i=k + 1; i < n; i++) {
      for (int j=0; j < nx; j++) {
        X[i][j]-=X[k][j] * LU[i][k];
      }
    }
  }
  for (int k=n - 1; k >= 0; k--) {
    for (int j=0; j < nx; j++) {
      X[k][j]/=LU[k][k];
    }
    for (int i=0; i < k; i++) {
      for (int j=0; j < nx; j++) {
        X[i][j]-=X[k][j] * LU[i][k];
      }
    }
  }
  return Xmat;
}

/** 
 * Returns the revision string.
 * @return		the revision
 */
public String getRevision(){
  return RevisionUtils.extract("$Revision: 5953 $");
}
}
