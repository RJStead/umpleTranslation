namespace weka.gui.graphvisualizer;

class GraphVisualizerMouseMotionListener
{
  isA MouseMotionAdapter;
 depend java.awt.BorderLayout;
 depend java.awt.Color;
 depend java.awt.Container;
 depend java.awt.Dialog.ModalityType;
 depend java.awt.Dimension;
 depend java.awt.Font;
 depend java.awt.FontMetrics;
 depend java.awt.Frame;
 depend java.awt.Graphics;
 depend java.awt.Graphics2D;
 depend java.awt.GridBagConstraints;
 depend java.awt.GridBagLayout;
 depend java.awt.Insets;
 depend java.awt.LayoutManager;
 depend java.awt.Rectangle;
 depend java.awt.RenderingHints;
 depend java.awt.event.ActionEvent;
 depend java.awt.event.ActionListener;
 depend java.awt.event.MouseAdapter;
 depend java.awt.event.MouseEvent;
 depend java.awt.event.MouseMotionAdapter;
 depend java.io.FileInputStream;
 depend java.io.FileReader;
 depend java.io.IOException;
 depend java.io.InputStream;
 depend java.io.Reader;
 depend java.util.ArrayList;
 depend javax.swing.BorderFactory;
 depend javax.swing.ImageIcon;
 depend javax.swing.JButton;
 depend javax.swing.JCheckBox;
 depend javax.swing.JDialog;
 depend javax.swing.JFileChooser;
 depend javax.swing.JFrame;
 depend javax.swing.JLabel;
 depend javax.swing.JOptionPane;
 depend javax.swing.JPanel;
 depend javax.swing.JScrollPane;
 depend javax.swing.JTable;
 depend javax.swing.JTextField;
 depend javax.swing.JToolBar;
 depend javax.swing.table.AbstractTableModel;
 depend weka.gui.ExtensionFileFilter;
 depend weka.gui.visualize.PrintablePanel;
/** 
 * for serialization 
 */
private static final long serialVersionUID=-2038911085935515624L;

/** 
 * Vector containing nodes 
 */
protected ArrayList<GraphNode> m_nodes=new ArrayList<GraphNode>();

/** 
 * Vector containing edges 
 */
protected ArrayList<GraphEdge> m_edges=new ArrayList<GraphEdge>();

/** 
 * The current LayoutEngine 
 */
protected LayoutEngine m_le;

/** 
 * Panel actually displaying the graph 
 */
protected GraphPanel m_gp;

/** 
 * String containing graph's name 
 */
protected String graphID;

/** 
 * Save button to save the current graph in DOT or XMLBIF format. The graph should be layed out again to get the original form if reloaded from command line, as the formats do not allow saving specific information for a properly layed out graph.
 */
protected JButton m_jBtSave;

/** 
 * path for icons 
 */
private final String ICONPATH="weka/gui/graphvisualizer/icons/";

private final FontMetrics fm=this.getFontMetrics(this.getFont());

private double scale=1;

private int nodeHeight=2 * fm.getHeight(), nodeWidth=24;

private int paddedNodeWidth=24 + 8;

/** 
 * TextField for node's width 
 */
private final JTextField jTfNodeWidth=new JTextField(3);

/** 
 * TextField for nodes height 
 */
private final JTextField jTfNodeHeight=new JTextField(3);

/** 
 * Button for laying out the graph again, necessary after changing node's size or some other property of the layout engine
 */
private final JButton jBtLayout;

/** 
 * used for setting appropriate node size 
 */
private int maxStringWidth=0;

/** 
 * used when using zoomIn and zoomOut buttons 
 */
private final int[] zoomPercents={10,25,50,75,100,125,150,175,200,225,250,275,300,350,400,450,500,550,600,650,700,800,900,999};

/** 
 * this contains the m_gp GraphPanel 
 */
JScrollPane m_js;

/** 
 * for serialization 
 */
private static final long serialVersionUID=-3562813603236753173L;

/** 
 * for serialization 
 */
private static final long serialVersionUID=-4789813491347366596L;

final String[] columnNames;

final double[][] data;

int x, y, nx, ny;

Rectangle r;

int x, y, nx, ny;

Rectangle r;

GraphNode lastNode;

/** 
 * Constructor<br> Sets up the gui and initializes all the other previously uninitialized variables.
 */
public GraphVisualizer(){
  m_gp=new GraphPanel();
  m_js=new JScrollPane(m_gp);
  m_le=new HierarchicalBCEngine(m_nodes,m_edges,paddedNodeWidth,nodeHeight);
  m_le.addLayoutCompleteEventListener(this);
  m_jBtSave=new JButton();
  java.net.URL tempURL=ClassLoader.getSystemResource(ICONPATH + "save.gif");
  if (tempURL != null) {
    m_jBtSave.setIcon(new ImageIcon(tempURL));
  }
 else {
    System.err.println(ICONPATH + "save.gif not found for weka.gui.graphvisualizer.Graph");
  }
  m_jBtSave.setToolTipText("Save Graph");
  m_jBtSave.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent ae){
      JFileChooser fc=new JFileChooser(System.getProperty("user.dir"));
      ExtensionFileFilter ef1=new ExtensionFileFilter(".dot","DOT files");
      ExtensionFileFilter ef2=new ExtensionFileFilter(".xml","XML BIF files");
      fc.addChoosableFileFilter(ef1);
      fc.addChoosableFileFilter(ef2);
      fc.setDialogTitle("Save Graph As");
      int rval=fc.showSaveDialog(GraphVisualizer.this);
      if (rval == JFileChooser.APPROVE_OPTION) {
        if (fc.getFileFilter() == ef2) {
          String filename=fc.getSelectedFile().toString();
          if (!filename.endsWith(".xml")) {
            filename=filename.concat(".xml");
          }
          BIFParser.writeXMLBIF03(filename,graphID,m_nodes,m_edges);
        }
 else {
          String filename=fc.getSelectedFile().toString();
          if (!filename.endsWith(".dot")) {
            filename=filename.concat(".dot");
          }
          DotParser.writeDOT(filename,graphID,m_nodes,m_edges);
        }
      }
    }
  }
);
  final JButton jBtZoomIn=new JButton();
  tempURL=ClassLoader.getSystemResource(ICONPATH + "zoomin.gif");
  if (tempURL != null) {
    jBtZoomIn.setIcon(new ImageIcon(tempURL));
  }
 else {
    System.err.println(ICONPATH + "zoomin.gif not found for weka.gui.graphvisualizer.Graph");
  }
  jBtZoomIn.setToolTipText("Zoom In");
  final JButton jBtZoomOut=new JButton();
  tempURL=ClassLoader.getSystemResource(ICONPATH + "zoomout.gif");
  if (tempURL != null) {
    jBtZoomOut.setIcon(new ImageIcon(tempURL));
  }
 else {
    System.err.println(ICONPATH + "zoomout.gif not found for weka.gui.graphvisualizer.Graph");
  }
  jBtZoomOut.setToolTipText("Zoom Out");
  final JTextField jTfZoom=new JTextField("100%");
  jTfZoom.setMinimumSize(jTfZoom.getPreferredSize());
  jTfZoom.setHorizontalAlignment(JTextField.CENTER);
  jTfZoom.setToolTipText("Zoom");
  jTfZoom.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent ae){
      JTextField jt=(JTextField)ae.getSource();
      try {
        int i=-1;
        i=jt.getText().indexOf('%');
        if (i == -1) {
          i=Integer.parseInt(jt.getText());
        }
 else {
          i=Integer.parseInt(jt.getText().substring(0,i));
        }
        if (i <= 999) {
          scale=i / 100D;
        }
        jt.setText((int)(scale * 100) + "%");
        if (scale > 0.1) {
          if (!jBtZoomOut.isEnabled()) {
            jBtZoomOut.setEnabled(true);
          }
        }
 else {
          jBtZoomOut.setEnabled(false);
        }
        if (scale < 9.99) {
          if (!jBtZoomIn.isEnabled()) {
            jBtZoomIn.setEnabled(true);
          }
        }
 else {
          jBtZoomIn.setEnabled(false);
        }
        setAppropriateSize();
        m_gp.repaint();
        m_gp.invalidate();
        m_js.revalidate();
      }
 catch (      NumberFormatException ne) {
        JOptionPane.showMessageDialog(GraphVisualizer.this.getParent(),"Invalid integer entered for zoom.","Error",JOptionPane.ERROR_MESSAGE);
        jt.setText((scale * 100) + "%");
      }
    }
  }
);
  jBtZoomIn.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent ae){
      int i=0, s=(int)(scale * 100);
      if (s < 300) {
        i=s / 25;
      }
 else       if (s < 700) {
        i=6 + s / 50;
      }
 else {
        i=13 + s / 100;
      }
      if (s >= 999) {
        JButton b=(JButton)ae.getSource();
        b.setEnabled(false);
        return;
      }
 else       if (s >= 10) {
        if (i >= 22) {
          JButton b=(JButton)ae.getSource();
          b.setEnabled(false);
        }
        if (s == 10 && !jBtZoomOut.isEnabled()) {
          jBtZoomOut.setEnabled(true);
        }
        jTfZoom.setText(zoomPercents[i + 1] + "%");
        scale=zoomPercents[i + 1] / 100D;
      }
 else {
        if (!jBtZoomOut.isEnabled()) {
          jBtZoomOut.setEnabled(true);
        }
        jTfZoom.setText(zoomPercents[0] + "%");
        scale=zoomPercents[0] / 100D;
      }
      setAppropriateSize();
      m_gp.repaint();
      m_gp.invalidate();
      m_js.revalidate();
    }
  }
);
  jBtZoomOut.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent ae){
      int i=0, s=(int)(scale * 100);
      if (s < 300) {
        i=(int)Math.ceil(s / 25D);
      }
 else       if (s < 700) {
        i=6 + (int)Math.ceil(s / 50D);
      }
 else {
        i=13 + (int)Math.ceil(s / 100D);
      }
      if (s <= 10) {
        JButton b=(JButton)ae.getSource();
        b.setEnabled(false);
      }
 else       if (s < 999) {
        if (i <= 1) {
          JButton b=(JButton)ae.getSource();
          b.setEnabled(false);
        }
        jTfZoom.setText(zoomPercents[i - 1] + "%");
        scale=zoomPercents[i - 1] / 100D;
      }
 else {
        if (!jBtZoomIn.isEnabled()) {
          jBtZoomIn.setEnabled(true);
        }
        jTfZoom.setText(zoomPercents[22] + "%");
        scale=zoomPercents[22] / 100D;
      }
      setAppropriateSize();
      m_gp.repaint();
      m_gp.invalidate();
      m_js.revalidate();
    }
  }
);
  JButton jBtExtraControls=new JButton();
  tempURL=ClassLoader.getSystemResource(ICONPATH + "extra.gif");
  if (tempURL != null) {
    jBtExtraControls.setIcon(new ImageIcon(tempURL));
  }
 else {
    System.err.println(ICONPATH + "extra.gif not found for weka.gui.graphvisualizer.Graph");
  }
  jBtExtraControls.setToolTipText("Show/Hide extra controls");
  final JCheckBox jCbCustomNodeSize=new JCheckBox("Custom Node Size");
  final JLabel jLbNodeWidth=new JLabel("Width");
  final JLabel jLbNodeHeight=new JLabel("Height");
  jTfNodeWidth.setHorizontalAlignment(JTextField.CENTER);
  jTfNodeWidth.setText("" + nodeWidth);
  jTfNodeHeight.setHorizontalAlignment(JTextField.CENTER);
  jTfNodeHeight.setText("" + nodeHeight);
  jLbNodeWidth.setEnabled(false);
  jTfNodeWidth.setEnabled(false);
  jLbNodeHeight.setEnabled(false);
  jTfNodeHeight.setEnabled(false);
  jCbCustomNodeSize.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent ae){
      if (((JCheckBox)ae.getSource()).isSelected()) {
        jLbNodeWidth.setEnabled(true);
        jTfNodeWidth.setEnabled(true);
        jLbNodeHeight.setEnabled(true);
        jTfNodeHeight.setEnabled(true);
      }
 else {
        jLbNodeWidth.setEnabled(false);
        jTfNodeWidth.setEnabled(false);
        jLbNodeHeight.setEnabled(false);
        jTfNodeHeight.setEnabled(false);
        setAppropriateNodeSize();
      }
    }
  }
);
  jBtLayout=new JButton("Layout Graph");
  jBtLayout.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent ae){
      int tmpW, tmpH;
      if (jCbCustomNodeSize.isSelected()) {
        try {
          tmpW=Integer.parseInt(jTfNodeWidth.getText());
        }
 catch (        NumberFormatException ne) {
          JOptionPane.showMessageDialog(GraphVisualizer.this.getParent(),"Invalid integer entered for node width.","Error",JOptionPane.ERROR_MESSAGE);
          tmpW=nodeWidth;
          jTfNodeWidth.setText("" + nodeWidth);
        }
        try {
          tmpH=Integer.parseInt(jTfNodeHeight.getText());
        }
 catch (        NumberFormatException ne) {
          JOptionPane.showMessageDialog(GraphVisualizer.this.getParent(),"Invalid integer entered for node height.","Error",JOptionPane.ERROR_MESSAGE);
          tmpH=nodeHeight;
          jTfNodeWidth.setText("" + nodeHeight);
        }
        if (tmpW != nodeWidth || tmpH != nodeHeight) {
          nodeWidth=tmpW;
          paddedNodeWidth=nodeWidth + 8;
          nodeHeight=tmpH;
        }
      }
      JButton bt=(JButton)ae.getSource();
      bt.setEnabled(false);
      m_le.setNodeSize(paddedNodeWidth,nodeHeight);
      m_le.layoutGraph();
    }
  }
);
  GridBagConstraints gbc=new GridBagConstraints();
  final JPanel p=new JPanel(new GridBagLayout());
  gbc.gridwidth=GridBagConstraints.REMAINDER;
  gbc.anchor=GridBagConstraints.NORTHWEST;
  gbc.fill=GridBagConstraints.NONE;
  p.add(m_le.getControlPanel(),gbc);
  gbc.gridwidth=1;
  gbc.insets=new Insets(8,0,0,0);
  gbc.anchor=GridBagConstraints.NORTHWEST;
  gbc.gridwidth=GridBagConstraints.REMAINDER;
  p.add(jCbCustomNodeSize,gbc);
  gbc.insets=new Insets(0,0,0,0);
  gbc.gridwidth=GridBagConstraints.REMAINDER;
  Container c=new Container();
  c.setLayout(new GridBagLayout());
  gbc.gridwidth=GridBagConstraints.RELATIVE;
  c.add(jLbNodeWidth,gbc);
  gbc.gridwidth=GridBagConstraints.REMAINDER;
  c.add(jTfNodeWidth,gbc);
  gbc.gridwidth=GridBagConstraints.RELATIVE;
  c.add(jLbNodeHeight,gbc);
  gbc.gridwidth=GridBagConstraints.REMAINDER;
  c.add(jTfNodeHeight,gbc);
  gbc.fill=GridBagConstraints.HORIZONTAL;
  p.add(c,gbc);
  gbc.anchor=GridBagConstraints.NORTHWEST;
  gbc.insets=new Insets(8,0,0,0);
  gbc.fill=GridBagConstraints.HORIZONTAL;
  p.add(jBtLayout,gbc);
  gbc.fill=GridBagConstraints.NONE;
  p.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createTitledBorder("ExtraControls"),BorderFactory.createEmptyBorder(4,4,4,4)));
  p.setPreferredSize(new Dimension(0,0));
  final JToolBar jTbTools=new JToolBar();
  jTbTools.setFloatable(false);
  jTbTools.setLayout(new GridBagLayout());
  gbc.anchor=GridBagConstraints.NORTHWEST;
  gbc.gridwidth=GridBagConstraints.REMAINDER;
  gbc.insets=new Insets(0,0,0,0);
  jTbTools.add(p,gbc);
  gbc.gridwidth=1;
  jTbTools.add(m_jBtSave,gbc);
  jTbTools.addSeparator(new Dimension(2,2));
  jTbTools.add(jBtZoomIn,gbc);
  gbc.fill=GridBagConstraints.VERTICAL;
  gbc.weighty=1;
  JPanel p2=new JPanel(new BorderLayout());
  p2.setPreferredSize(jTfZoom.getPreferredSize());
  p2.setMinimumSize(jTfZoom.getPreferredSize());
  p2.add(jTfZoom,BorderLayout.CENTER);
  jTbTools.add(p2,gbc);
  gbc.weighty=0;
  gbc.fill=GridBagConstraints.NONE;
  jTbTools.add(jBtZoomOut,gbc);
  jTbTools.addSeparator(new Dimension(2,2));
  jTbTools.add(jBtExtraControls,gbc);
  jTbTools.addSeparator(new Dimension(4,2));
  gbc.weightx=1;
  gbc.fill=GridBagConstraints.BOTH;
  jTbTools.add(m_le.getProgressBar(),gbc);
  jBtExtraControls.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent ae){
      Dimension d=p.getPreferredSize();
      if (d.width == 0 || d.height == 0) {
        LayoutManager lm=p.getLayout();
        Dimension d2=lm.preferredLayoutSize(p);
        p.setPreferredSize(d2);
        jTbTools.revalidate();
      }
 else {
        p.setPreferredSize(new Dimension(0,0));
        jTbTools.revalidate();
      }
    }
  }
);
  this.setLayout(new BorderLayout());
  this.add(jTbTools,BorderLayout.NORTH);
  this.add(m_js,BorderLayout.CENTER);
}

@Override public void actionPerformed(ActionEvent ae){
  JFileChooser fc=new JFileChooser(System.getProperty("user.dir"));
  ExtensionFileFilter ef1=new ExtensionFileFilter(".dot","DOT files");
  ExtensionFileFilter ef2=new ExtensionFileFilter(".xml","XML BIF files");
  fc.addChoosableFileFilter(ef1);
  fc.addChoosableFileFilter(ef2);
  fc.setDialogTitle("Save Graph As");
  int rval=fc.showSaveDialog(GraphVisualizer.this);
  if (rval == JFileChooser.APPROVE_OPTION) {
    if (fc.getFileFilter() == ef2) {
      String filename=fc.getSelectedFile().toString();
      if (!filename.endsWith(".xml")) {
        filename=filename.concat(".xml");
      }
      BIFParser.writeXMLBIF03(filename,graphID,m_nodes,m_edges);
    }
 else {
      String filename=fc.getSelectedFile().toString();
      if (!filename.endsWith(".dot")) {
        filename=filename.concat(".dot");
      }
      DotParser.writeDOT(filename,graphID,m_nodes,m_edges);
    }
  }
}

@Override public void actionPerformed(ActionEvent ae){
  JTextField jt=(JTextField)ae.getSource();
  try {
    int i=-1;
    i=jt.getText().indexOf('%');
    if (i == -1) {
      i=Integer.parseInt(jt.getText());
    }
 else {
      i=Integer.parseInt(jt.getText().substring(0,i));
    }
    if (i <= 999) {
      scale=i / 100D;
    }
    jt.setText((int)(scale * 100) + "%");
    if (scale > 0.1) {
      if (!jBtZoomOut.isEnabled()) {
        jBtZoomOut.setEnabled(true);
      }
    }
 else {
      jBtZoomOut.setEnabled(false);
    }
    if (scale < 9.99) {
      if (!jBtZoomIn.isEnabled()) {
        jBtZoomIn.setEnabled(true);
      }
    }
 else {
      jBtZoomIn.setEnabled(false);
    }
    setAppropriateSize();
    m_gp.repaint();
    m_gp.invalidate();
    m_js.revalidate();
  }
 catch (  NumberFormatException ne) {
    JOptionPane.showMessageDialog(GraphVisualizer.this.getParent(),"Invalid integer entered for zoom.","Error",JOptionPane.ERROR_MESSAGE);
    jt.setText((scale * 100) + "%");
  }
}

@Override public void actionPerformed(ActionEvent ae){
  int i=0, s=(int)(scale * 100);
  if (s < 300) {
    i=s / 25;
  }
 else   if (s < 700) {
    i=6 + s / 50;
  }
 else {
    i=13 + s / 100;
  }
  if (s >= 999) {
    JButton b=(JButton)ae.getSource();
    b.setEnabled(false);
    return;
  }
 else   if (s >= 10) {
    if (i >= 22) {
      JButton b=(JButton)ae.getSource();
      b.setEnabled(false);
    }
    if (s == 10 && !jBtZoomOut.isEnabled()) {
      jBtZoomOut.setEnabled(true);
    }
    jTfZoom.setText(zoomPercents[i + 1] + "%");
    scale=zoomPercents[i + 1] / 100D;
  }
 else {
    if (!jBtZoomOut.isEnabled()) {
      jBtZoomOut.setEnabled(true);
    }
    jTfZoom.setText(zoomPercents[0] + "%");
    scale=zoomPercents[0] / 100D;
  }
  setAppropriateSize();
  m_gp.repaint();
  m_gp.invalidate();
  m_js.revalidate();
}

@Override public void actionPerformed(ActionEvent ae){
  int i=0, s=(int)(scale * 100);
  if (s < 300) {
    i=(int)Math.ceil(s / 25D);
  }
 else   if (s < 700) {
    i=6 + (int)Math.ceil(s / 50D);
  }
 else {
    i=13 + (int)Math.ceil(s / 100D);
  }
  if (s <= 10) {
    JButton b=(JButton)ae.getSource();
    b.setEnabled(false);
  }
 else   if (s < 999) {
    if (i <= 1) {
      JButton b=(JButton)ae.getSource();
      b.setEnabled(false);
    }
    jTfZoom.setText(zoomPercents[i - 1] + "%");
    scale=zoomPercents[i - 1] / 100D;
  }
 else {
    if (!jBtZoomIn.isEnabled()) {
      jBtZoomIn.setEnabled(true);
    }
    jTfZoom.setText(zoomPercents[22] + "%");
    scale=zoomPercents[22] / 100D;
  }
  setAppropriateSize();
  m_gp.repaint();
  m_gp.invalidate();
  m_js.revalidate();
}

@Override public void actionPerformed(ActionEvent ae){
  if (((JCheckBox)ae.getSource()).isSelected()) {
    jLbNodeWidth.setEnabled(true);
    jTfNodeWidth.setEnabled(true);
    jLbNodeHeight.setEnabled(true);
    jTfNodeHeight.setEnabled(true);
  }
 else {
    jLbNodeWidth.setEnabled(false);
    jTfNodeWidth.setEnabled(false);
    jLbNodeHeight.setEnabled(false);
    jTfNodeHeight.setEnabled(false);
    setAppropriateNodeSize();
  }
}

@Override public void actionPerformed(ActionEvent ae){
  int tmpW, tmpH;
  if (jCbCustomNodeSize.isSelected()) {
    try {
      tmpW=Integer.parseInt(jTfNodeWidth.getText());
    }
 catch (    NumberFormatException ne) {
      JOptionPane.showMessageDialog(GraphVisualizer.this.getParent(),"Invalid integer entered for node width.","Error",JOptionPane.ERROR_MESSAGE);
      tmpW=nodeWidth;
      jTfNodeWidth.setText("" + nodeWidth);
    }
    try {
      tmpH=Integer.parseInt(jTfNodeHeight.getText());
    }
 catch (    NumberFormatException ne) {
      JOptionPane.showMessageDialog(GraphVisualizer.this.getParent(),"Invalid integer entered for node height.","Error",JOptionPane.ERROR_MESSAGE);
      tmpH=nodeHeight;
      jTfNodeWidth.setText("" + nodeHeight);
    }
    if (tmpW != nodeWidth || tmpH != nodeHeight) {
      nodeWidth=tmpW;
      paddedNodeWidth=nodeWidth + 8;
      nodeHeight=tmpH;
    }
  }
  JButton bt=(JButton)ae.getSource();
  bt.setEnabled(false);
  m_le.setNodeSize(paddedNodeWidth,nodeHeight);
  m_le.layoutGraph();
}

@Override public void actionPerformed(ActionEvent ae){
  Dimension d=p.getPreferredSize();
  if (d.width == 0 || d.height == 0) {
    LayoutManager lm=p.getLayout();
    Dimension d2=lm.preferredLayoutSize(p);
    p.setPreferredSize(d2);
    jTbTools.revalidate();
  }
 else {
    p.setPreferredSize(new Dimension(0,0));
    jTbTools.revalidate();
  }
}

/** 
 * This method sets the node size that is appropriate considering the maximum label size that is present. It is used internally when custom node size checkbox is unchecked.
 */
protected void setAppropriateNodeSize(){
  int strWidth;
  if (maxStringWidth == 0) {
    for (int i=0; i < m_nodes.size(); i++) {
      strWidth=fm.stringWidth(m_nodes.get(i).lbl);
      if (strWidth > maxStringWidth) {
        maxStringWidth=strWidth;
      }
    }
  }
  nodeWidth=maxStringWidth + 4;
  paddedNodeWidth=nodeWidth + 8;
  jTfNodeWidth.setText("" + nodeWidth);
  nodeHeight=2 * fm.getHeight();
  jTfNodeHeight.setText("" + nodeHeight);
}

/** 
 * Sets the preferred size for m_gp GraphPanel to the minimum size that is neccessary to display the graph.
 */
protected void setAppropriateSize(){
  int maxX=0, maxY=0;
  m_gp.setScale(scale,scale);
  for (int i=0; i < m_nodes.size(); i++) {
    GraphNode n=m_nodes.get(i);
    if (maxX < n.x) {
      maxX=n.x;
    }
    if (maxY < n.y) {
      maxY=n.y;
    }
  }
  m_gp.setPreferredSize(new Dimension((int)((maxX + paddedNodeWidth + 2) * scale),(int)((maxY + nodeHeight + 2) * scale)));
}

/** 
 * This method is an implementation for LayoutCompleteEventListener class. It sets the size appropriate for m_gp GraphPanel and and revalidates it's container JScrollPane once a LayoutCompleteEvent is received from the LayoutEngine.
 */
@Override public void layoutCompleted(LayoutCompleteEvent le){
  setAppropriateSize();
  m_gp.invalidate();
  m_js.revalidate();
  m_gp.repaint();
  jBtLayout.setEnabled(true);
}

/** 
 * This method lays out the graph by calling the LayoutEngine's layoutGraph() method. This method should be called to display the graph nicely, unless the input XMLBIF03 already contains some layout information (ie the x,y positions of nodes.
 */
public void layoutGraph(){
  if (m_le != null) {
    m_le.layoutGraph();
  }
}

/** 
 * BIF reader<br> Reads a graph description in XMLBIF03 from a string
 */
public void readBIF(String instring) throws BIFFormatException {
  BIFParser bp=new BIFParser(instring,m_nodes,m_edges);
  try {
    graphID=bp.parse();
  }
 catch (  BIFFormatException bf) {
    System.out.println("BIF format error");
    bf.printStackTrace();
  }
catch (  Exception ex) {
    ex.printStackTrace();
    return;
  }
  setAppropriateNodeSize();
  if (m_le != null) {
    m_le.setNodeSize(paddedNodeWidth,nodeHeight);
  }
}

/** 
 * BIF reader<br> Reads a graph description in XMLBIF03 from an InputStrem
 */
public void readBIF(InputStream instream) throws BIFFormatException {
  BIFParser bp=new BIFParser(instream,m_nodes,m_edges);
  try {
    graphID=bp.parse();
  }
 catch (  BIFFormatException bf) {
    System.out.println("BIF format error");
    bf.printStackTrace();
  }
catch (  Exception ex) {
    ex.printStackTrace();
    return;
  }
  setAppropriateNodeSize();
  if (m_le != null) {
    m_le.setNodeSize(paddedNodeWidth,nodeHeight);
  }
  setAppropriateSize();
}

/** 
 * Dot reader<br> Reads a graph description in DOT format from a string
 */
public void readDOT(Reader input){
  DotParser dp=new DotParser(input,m_nodes,m_edges);
  graphID=dp.parse();
  setAppropriateNodeSize();
  if (m_le != null) {
    m_le.setNodeSize(paddedNodeWidth,nodeHeight);
    jBtLayout.setEnabled(false);
    layoutGraph();
  }
}

public GraphPanel(){
  super();
  this.addMouseListener(new GraphVisualizerMouseListener());
  this.addMouseMotionListener(new GraphVisualizerMouseMotionListener());
  this.setToolTipText("");
}

@Override public String getToolTipText(MouseEvent me){
  int x, y, nx, ny;
  Rectangle r;
  GraphNode n;
  Dimension d=m_gp.getPreferredSize();
  x=y=nx=ny=0;
  if (d.width < m_gp.getWidth()) {
    nx=(int)((nx + m_gp.getWidth() / 2 - d.width / 2) / scale);
  }
  if (d.height < m_gp.getHeight()) {
    ny=(int)((ny + m_gp.getHeight() / 2 - d.height / 2) / scale);
  }
  r=new Rectangle(0,0,(int)(paddedNodeWidth * scale),(int)(nodeHeight * scale));
  x+=me.getX();
  y+=me.getY();
  int i;
  for (i=0; i < m_nodes.size(); i++) {
    n=m_nodes.get(i);
    if (n.nodeType != NORMAL) {
      return null;
    }
    r.x=(int)((nx + n.x) * scale);
    r.y=(int)((ny + n.y) * scale);
    if (r.contains(x,y)) {
      if (n.probs == null) {
        return n.lbl;
      }
 else {
        return n.lbl + " (click to view the probability dist. table)";
      }
    }
  }
  return null;
}

@Override public void paintComponent(Graphics gr){
  Graphics2D g=(Graphics2D)gr;
  RenderingHints rh=new RenderingHints(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  rh.put(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_SPEED);
  g.setRenderingHints(rh);
  g.scale(scale,scale);
  Rectangle r=g.getClipBounds();
  g.clearRect(r.x,r.y,r.width,r.height);
  int x=0, y=0;
  Dimension d=this.getPreferredSize();
  if (d.width < this.getWidth()) {
    x=(int)((x + this.getWidth() / 2 - d.width / 2) / scale);
  }
  if (d.height < this.getHeight()) {
    y=(int)((y + this.getHeight() / 2 - d.height / 2) / scale);
  }
  for (int index=0; index < m_nodes.size(); index++) {
    GraphNode n=m_nodes.get(index);
    if (n.nodeType == NORMAL) {
      g.setColor(this.getBackground().darker().darker());
      g.fillOval(x + n.x + paddedNodeWidth - nodeWidth - (paddedNodeWidth - nodeWidth) / 2,y + n.y,nodeWidth,nodeHeight);
      g.setColor(Color.white);
      if (fm.stringWidth(n.lbl) <= nodeWidth) {
        g.drawString(n.lbl,x + n.x + paddedNodeWidth / 2 - fm.stringWidth(n.lbl) / 2,y + n.y + nodeHeight / 2 + fm.getHeight() / 2 - 2);
      }
 else       if (fm.stringWidth(n.ID) <= nodeWidth) {
        g.drawString(n.ID,x + n.x + paddedNodeWidth / 2 - fm.stringWidth(n.ID) / 2,y + n.y + nodeHeight / 2 + fm.getHeight() / 2 - 2);
      }
 else       if (fm.stringWidth(Integer.toString(index)) <= nodeWidth) {
        g.drawString(Integer.toString(index),x + n.x + paddedNodeWidth / 2 - fm.stringWidth(Integer.toString(index)) / 2,y + n.y + nodeHeight / 2 + fm.getHeight() / 2 - 2);
      }
      g.setColor(Color.black);
    }
 else {
      g.drawLine(x + n.x + paddedNodeWidth / 2,y + n.y,x + n.x + paddedNodeWidth / 2,y + n.y + nodeHeight);
    }
    GraphNode n2;
    int x1, y1, x2, y2;
    if (n.edges != null) {
      for (      int[] edge : n.edges) {
        if (edge[1] > 0) {
          n2=m_nodes.get(edge[0]);
          x1=n.x + paddedNodeWidth / 2;
          y1=n.y + nodeHeight;
          x2=n2.x + paddedNodeWidth / 2;
          y2=n2.y;
          g.drawLine(x + x1,y + y1,x + x2,y + y2);
          if (edge[1] == DIRECTED) {
            if (n2.nodeType == GraphConstants.NORMAL) {
              drawArrow(g,x + x1,y + y1,x + x2,y + y2);
            }
          }
 else           if (edge[1] == REVERSED) {
            if (n.nodeType == NORMAL) {
              drawArrow(g,x + x2,y + y2,x + x1,y + y1);
            }
          }
 else           if (edge[1] == DOUBLE) {
            if (n.nodeType == NORMAL) {
              drawArrow(g,x + x2,y + y2,x + x1,y + y1);
            }
            if (n2.nodeType == NORMAL) {
              drawArrow(g,x + x1,y + y1,x + x2,y + y2);
            }
          }
        }
      }
    }
  }
}

/** 
 * This method draws an arrow on a line from (x1,y1) to (x2,y2). The arrow head is seated on (x2,y2) and is in the direction of the line. If the arrow is needed to be drawn in the opposite direction then simply swap the order of (x1, y1) and (x2, y2) when calling this function.
 */
protected void drawArrow(Graphics g,int x1,int y1,int x2,int y2){
  if (x1 == x2) {
    if (y1 < y2) {
      g.drawLine(x2,y2,x2 + 4,y2 - 8);
      g.drawLine(x2,y2,x2 - 4,y2 - 8);
    }
 else {
      g.drawLine(x2,y2,x2 + 4,y2 + 8);
      g.drawLine(x2,y2,x2 - 4,y2 + 8);
    }
  }
 else {
    double hyp=0, base=0, perp=0, theta, beta;
    int x3=0, y3=0;
    if (x2 < x1) {
      base=x1 - x2;
      hyp=Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      theta=Math.acos(base / hyp);
    }
 else {
      base=x1 - x2;
      hyp=Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      theta=Math.acos(base / hyp);
    }
    beta=30 * Math.PI / 180;
    hyp=8;
    base=Math.cos(theta - beta) * hyp;
    perp=Math.sin(theta - beta) * hyp;
    x3=(int)(x2 + base);
    if (y1 < y2) {
      y3=(int)(y2 - perp);
    }
 else {
      y3=(int)(y2 + perp);
    }
    g.drawLine(x2,y2,x3,y3);
    base=Math.cos(theta + beta) * hyp;
    perp=Math.sin(theta + beta) * hyp;
    x3=(int)(x2 + base);
    if (y1 < y2) {
      y3=(int)(y2 - perp);
    }
 else {
      y3=(int)(y2 + perp);
    }
    g.drawLine(x2,y2,x3,y3);
  }
}

/** 
 * This method highlights a given node and all its children and the edges coming out of it.
 */
public void highLight(GraphNode n){
  Graphics2D g=(Graphics2D)this.getGraphics();
  RenderingHints rh=new RenderingHints(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  rh.put(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_SPEED);
  g.setRenderingHints(rh);
  g.setPaintMode();
  g.scale(scale,scale);
  int x=0, y=0;
  Dimension d=this.getPreferredSize();
  if (d.width < this.getWidth()) {
    x=(int)((x + this.getWidth() / 2 - d.width / 2) / scale);
  }
  if (d.height < this.getHeight()) {
    y=(int)((y + this.getHeight() / 2 - d.height / 2) / scale);
  }
  if (n.nodeType == NORMAL) {
    g.setXORMode(Color.green);
    g.fillOval(x + n.x + paddedNodeWidth - nodeWidth - (paddedNodeWidth - nodeWidth) / 2,y + n.y,nodeWidth,nodeHeight);
    g.setXORMode(Color.red);
    if (fm.stringWidth(n.lbl) <= nodeWidth) {
      g.drawString(n.lbl,x + n.x + paddedNodeWidth / 2 - fm.stringWidth(n.lbl) / 2,y + n.y + nodeHeight / 2 + fm.getHeight() / 2 - 2);
    }
 else     if (fm.stringWidth(n.ID) <= nodeWidth) {
      g.drawString(n.ID,x + n.x + paddedNodeWidth / 2 - fm.stringWidth(n.ID) / 2,y + n.y + nodeHeight / 2 + fm.getHeight() / 2 - 2);
    }
 else     if (fm.stringWidth(Integer.toString(m_nodes.indexOf(n))) <= nodeWidth) {
      g.drawString(Integer.toString(m_nodes.indexOf(n)),x + n.x + paddedNodeWidth / 2 - fm.stringWidth(Integer.toString(m_nodes.indexOf(n))) / 2,y + n.y + nodeHeight / 2 + fm.getHeight() / 2 - 2);
    }
    g.setXORMode(Color.green);
    GraphNode n2;
    int x1, y1, x2, y2;
    if (n.edges != null) {
      for (      int[] edge2 : n.edges) {
        if (edge2[1] == DIRECTED || edge2[1] == DOUBLE) {
          n2=m_nodes.get(edge2[0]);
          x1=n.x + paddedNodeWidth / 2;
          y1=n.y + nodeHeight;
          x2=n2.x + paddedNodeWidth / 2;
          y2=n2.y;
          g.drawLine(x + x1,y + y1,x + x2,y + y2);
          if (edge2[1] == DIRECTED) {
            if (n2.nodeType == GraphConstants.NORMAL) {
              drawArrow(g,x + x1,y + y1,x + x2,y + y2);
            }
          }
 else           if (edge2[1] == DOUBLE) {
            if (n.nodeType == NORMAL) {
              drawArrow(g,x + x2,y + y2,x + x1,y + y1);
            }
            if (n2.nodeType == NORMAL) {
              drawArrow(g,x + x1,y + y1,x + x2,y + y2);
            }
          }
          if (n2.nodeType == NORMAL) {
            g.fillOval(x + n2.x + paddedNodeWidth - nodeWidth - (paddedNodeWidth - nodeWidth) / 2,y + n2.y,nodeWidth,nodeHeight);
          }
          java.util.Vector<GraphNode> t=new java.util.Vector<GraphNode>();
          while (n2.nodeType != NORMAL || t.size() > 0) {
            if (t.size() > 0) {
              n2=t.get(0);
              t.removeElementAt(0);
            }
            if (n2.nodeType != NORMAL) {
              g.drawLine(x + n2.x + paddedNodeWidth / 2,y + n2.y,x + n2.x + paddedNodeWidth / 2,y + n2.y + nodeHeight);
              x1=n2.x + paddedNodeWidth / 2;
              y1=n2.y + nodeHeight;
              for (              int[] edge : n2.edges) {
                if (edge[1] > 0) {
                  GraphNode n3=m_nodes.get(edge[0]);
                  g.drawLine(x + x1,y + y1,x + n3.x + paddedNodeWidth / 2,y + n3.y);
                  if (n3.nodeType == NORMAL) {
                    g.fillOval(x + n3.x + paddedNodeWidth - nodeWidth - (paddedNodeWidth - nodeWidth) / 2,y + n3.y,nodeWidth,nodeHeight);
                    drawArrow(g,x + x1,y + y1,x + n3.x + paddedNodeWidth / 2,y + n3.y);
                  }
                  t.addElement(n3);
                }
              }
            }
          }
        }
 else         if (edge2[1] == -REVERSED || edge2[1] == -DOUBLE) {
          n2=m_nodes.get(edge2[0]);
          x1=n.x + paddedNodeWidth / 2;
          y1=n.y;
          x2=n2.x + paddedNodeWidth / 2;
          y2=n2.y + nodeHeight;
          g.drawLine(x + x1,y + y1,x + x2,y + y2);
          if (edge2[1] == -DOUBLE) {
            drawArrow(g,x + x2,y + y2,x + x1,y + y1);
            if (n2.nodeType != SINGULAR_DUMMY) {
              drawArrow(g,x + x1,y + y1,x + x2,y + y2);
            }
          }
          while (n2.nodeType != NORMAL) {
            g.drawLine(x + n2.x + paddedNodeWidth / 2,y + n2.y + nodeHeight,x + n2.x + paddedNodeWidth / 2,y + n2.y);
            x1=n2.x + paddedNodeWidth / 2;
            y1=n2.y;
            for (            int[] edge : n2.edges) {
              if (edge[1] < 0) {
                n2=m_nodes.get(edge[0]);
                g.drawLine(x + x1,y + y1,x + n2.x + paddedNodeWidth / 2,y + n2.y + nodeHeight);
                if (n2.nodeType != SINGULAR_DUMMY) {
                  drawArrow(g,x + x1,y + y1,x + n2.x + paddedNodeWidth / 2,y + n2.y + nodeHeight);
                }
                break;
              }
            }
          }
        }
      }
    }
  }
}

public GraphVisualizerTableModel(double[][] d,String[] c){
  data=d;
  columnNames=c;
}

@Override public int getColumnCount(){
  return columnNames.length;
}

@Override public int getRowCount(){
  return data.length;
}

@Override public String getColumnName(int col){
  return columnNames[col];
}

@Override public Object getValueAt(int row,int col){
  return new Double(data[row][col]);
}

@Override public Class<?> getColumnClass(int c){
  return getValueAt(0,c).getClass();
}

@Override public boolean isCellEditable(int row,int col){
  return false;
}

/** 
 * If the mouse is clicked on a node then this method displays a dialog box with the probability distribution table for that node IF it exists
 */
@Override public void mouseClicked(MouseEvent me){
  GraphNode n;
  Dimension d=m_gp.getPreferredSize();
  x=y=nx=ny=0;
  if (d.width < m_gp.getWidth()) {
    nx=(int)((nx + m_gp.getWidth() / 2 - d.width / 2) / scale);
  }
  if (d.height < m_gp.getHeight()) {
    ny=(int)((ny + m_gp.getHeight() / 2 - d.height / 2) / scale);
  }
  r=new Rectangle(0,0,(int)(paddedNodeWidth * scale),(int)(nodeHeight * scale));
  x+=me.getX();
  y+=me.getY();
  int i;
  for (i=0; i < m_nodes.size(); i++) {
    n=m_nodes.get(i);
    r.x=(int)((nx + n.x) * scale);
    r.y=(int)((ny + n.y) * scale);
    if (r.contains(x,y)) {
      if (n.probs == null) {
        return;
      }
      int noOfPrntsOutcomes=1;
      if (n.prnts != null) {
        for (        int prnt : n.prnts) {
          GraphNode n2=m_nodes.get(prnt);
          noOfPrntsOutcomes*=n2.outcomes.length;
        }
        if (noOfPrntsOutcomes > 511) {
          System.err.println("Too many outcomes of parents (" + noOfPrntsOutcomes + ") can't display probabilities");
          return;
        }
      }
      GraphVisualizerTableModel tm=new GraphVisualizerTableModel(n.probs,n.outcomes);
      JTable jTblProbs=new JTable(tm);
      JScrollPane js=new JScrollPane(jTblProbs);
      if (n.prnts != null) {
        GridBagConstraints gbc=new GridBagConstraints();
        JPanel jPlRowHeader=new JPanel(new GridBagLayout());
        int[] idx=new int[n.prnts.length];
        int[] lengths=new int[n.prnts.length];
        gbc.anchor=GridBagConstraints.NORTHWEST;
        gbc.fill=GridBagConstraints.HORIZONTAL;
        gbc.insets=new Insets(0,1,0,0);
        int addNum=0, temp=0;
        boolean dark=false;
        while (true) {
          GraphNode n2;
          gbc.gridwidth=1;
          for (int k=0; k < n.prnts.length; k++) {
            n2=m_nodes.get(n.prnts[k]);
            JLabel lb=new JLabel(n2.outcomes[idx[k]]);
            lb.setFont(new Font("Dialog",Font.PLAIN,12));
            lb.setOpaque(true);
            lb.setBorder(BorderFactory.createEmptyBorder(1,2,1,1));
            lb.setHorizontalAlignment(JLabel.CENTER);
            if (dark) {
              lb.setBackground(lb.getBackground().darker());
              lb.setForeground(Color.white);
            }
 else {
              lb.setForeground(Color.black);
            }
            temp=lb.getPreferredSize().width;
            lb.setPreferredSize(new Dimension(temp,jTblProbs.getRowHeight()));
            if (lengths[k] < temp) {
              lengths[k]=temp;
            }
            temp=0;
            if (k == n.prnts.length - 1) {
              gbc.gridwidth=GridBagConstraints.REMAINDER;
              dark=(dark == true) ? false : true;
            }
            jPlRowHeader.add(lb,gbc);
            addNum++;
          }
          for (int k=n.prnts.length - 1; k >= 0; k--) {
            n2=m_nodes.get(n.prnts[k]);
            if (idx[k] == n2.outcomes.length - 1 && k != 0) {
              idx[k]=0;
              continue;
            }
 else {
              idx[k]++;
              break;
            }
          }
          n2=m_nodes.get(n.prnts[0]);
          if (idx[0] == n2.outcomes.length) {
            JLabel lb=(JLabel)jPlRowHeader.getComponent(addNum - 1);
            jPlRowHeader.remove(addNum - 1);
            lb.setPreferredSize(new Dimension(lb.getPreferredSize().width,jTblProbs.getRowHeight()));
            gbc.gridwidth=GridBagConstraints.REMAINDER;
            gbc.weighty=1;
            jPlRowHeader.add(lb,gbc);
            gbc.weighty=0;
            break;
          }
        }
        gbc.gridwidth=1;
        JPanel jPlRowNames=new JPanel(new GridBagLayout());
        for (int j=0; j < n.prnts.length; j++) {
          JLabel lb2;
          JLabel lb1=new JLabel(m_nodes.get(n.prnts[j]).lbl);
          lb1.setBorder(BorderFactory.createEmptyBorder(1,2,1,1));
          Dimension tempd=lb1.getPreferredSize();
          if (tempd.width < lengths[j]) {
            lb1.setPreferredSize(new Dimension(lengths[j],tempd.height));
            lb1.setHorizontalAlignment(JLabel.CENTER);
            lb1.setMinimumSize(new Dimension(lengths[j],tempd.height));
          }
 else           if (tempd.width > lengths[j]) {
            lb2=(JLabel)jPlRowHeader.getComponent(j);
            lb2.setPreferredSize(new Dimension(tempd.width,lb2.getPreferredSize().height));
          }
          jPlRowNames.add(lb1,gbc);
        }
        js.setRowHeaderView(jPlRowHeader);
        js.setCorner(JScrollPane.UPPER_LEFT_CORNER,jPlRowNames);
      }
      JDialog jd=new JDialog((Frame)GraphVisualizer.this.getTopLevelAncestor(),"Probability Distribution Table For " + n.lbl,ModalityType.DOCUMENT_MODAL);
      jd.setSize(500,400);
      jd.setLocation(GraphVisualizer.this.getLocation().x + GraphVisualizer.this.getWidth() / 2 - 250,GraphVisualizer.this.getLocation().y + GraphVisualizer.this.getHeight() / 2 - 200);
      jd.getContentPane().setLayout(new BorderLayout());
      jd.getContentPane().add(js,BorderLayout.CENTER);
      jd.setVisible(true);
      return;
    }
  }
}

@Override public void mouseMoved(MouseEvent me){
  GraphNode n;
  Dimension d=m_gp.getPreferredSize();
  x=y=nx=ny=0;
  if (d.width < m_gp.getWidth()) {
    nx=(int)((nx + m_gp.getWidth() / 2 - d.width / 2) / scale);
  }
  if (d.height < m_gp.getHeight()) {
    ny=(int)((ny + m_gp.getHeight() / 2 - d.height / 2) / scale);
  }
  r=new Rectangle(0,0,(int)(paddedNodeWidth * scale),(int)(nodeHeight * scale));
  x+=me.getX();
  y+=me.getY();
  int i;
  for (i=0; i < m_nodes.size(); i++) {
    n=m_nodes.get(i);
    r.x=(int)((nx + n.x) * scale);
    r.y=(int)((ny + n.y) * scale);
    if (r.contains(x,y)) {
      if (n != lastNode) {
        m_gp.highLight(n);
        if (lastNode != null) {
          m_gp.highLight(lastNode);
        }
        lastNode=n;
      }
      break;
    }
  }
  if (i == m_nodes.size() && lastNode != null) {
    m_gp.repaint();
    lastNode=null;
  }
}

/** 
 * Main method to load a text file with the description of a graph from the command line
 */
public static void main(String[] args){
  weka.core.logging.Logger.log(weka.core.logging.Logger.Level.INFO,"Logging started");
  JFrame jf=new JFrame("Graph Visualizer");
  GraphVisualizer g=new GraphVisualizer();
  try {
    if (args[0].endsWith(".xml")) {
      g.readBIF(new FileInputStream(args[0]));
    }
 else {
      g.readDOT(new FileReader(args[0]));
    }
  }
 catch (  IOException ex) {
    ex.printStackTrace();
  }
catch (  BIFFormatException bf) {
    bf.printStackTrace();
    System.exit(-1);
  }
  jf.getContentPane().add(g);
  jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  jf.setSize(800,600);
  jf.setVisible(true);
}
}
