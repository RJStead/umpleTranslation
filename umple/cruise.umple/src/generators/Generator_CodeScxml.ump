/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

 */

namespace cruise.umple.compiler;

class ScxmlGenerator
{
  isA CodeGeneratorWithSubptions;
  depend java.io.*;
  depend java.util.*;
  depend cruise.umple.util.*;
  depend cruise.umple.compiler.exceptions.*;

  // Contains various aspects from an Umple file (.ump), such as classes, attributes, associations and methods.  Generated output is based
  // off of what's contained in here.
  UmpleModel model = null;
  String output = "";

  StringBuilder code = new StringBuilder();
  
  cr <<!
!>>

  textElement <<!<<=content>>!>>
  emit genTextElement(String content)(textElement, cr);
  
  header <<!<!--  EXPERIMENTAL SCXML OUTPUT, NOT READY FOR USE -->!>>
  emit genHeader()(header, cr);
  
  xmlTag <<!<?xml version="1.0" encoding="utf-8"?>!>>
  emit genXMLTag()(xmlTag, cr);
  
  tagAttribute <<! <<=key>>="<<=value>>"!>>
  emit genTagAttribute(String key, String value)(tagAttribute);
  
  scxmlOpeningTag <<!<scxml<<=name>> xmlns="http://www.w3.org/2005/07/scxml" xmlns:xi="http://www.w3.org/2001/XInclude" version="1.0">!>>
  scxmlClosingTag <<!</scxml>!>>
  scxmlEmptyTag <<!<scxml<<=name>> xmlns="http://www.w3.org/2005/07/scxml" xmlns:xi="http://www.w3.org/2001/XInclude" version="1.0"/>!>>
  emit genScxmlOpeningTag(String name)(scxmlOpeningTag, cr);
  emit genScxmlClosingTag()(scxmlClosingTag);
  emit genScxmlEmptyTag(String name)(scxmlEmptyTag, cr);
  
  stateOpeningTag <<!<state<<=id>>>!>>
  stateClosingTag <<!</state>!>>
  stateEmptyTag    <<!<state<<=id>>/>!>>
  emit genStateOpeningTag(String id)(stateOpeningTag, cr);
  emit genStateClosingTag()(stateClosingTag, cr);
  emit genStateEmptyTag(String id)(stateEmptyTag, cr);
  
  transitionOpeningTag <<!<transition<<=event>><<=cond>><<=target>><<=type>>>!>>
  transitionClosingTag <<!</transition>!>>
  transitionEmptyTag <<!<transition<<=event>><<=cond>><<=target>><<=type>>/>!>>
  emit genTransitionOpeningTag(String event, String cond, String target, String type)(transitionOpeningTag, cr);
  emit genTransitionClosingTag()(transitionClosingTag, cr);
  emit genTransitionTag(String event, String cond, String target, String type)(transitionEmptyTag, cr);
  
  raiseTag <<!<raise<<=event>>/>!>>
  emit genRaiseTag(String event)(raiseTag, cr);
  
  genericTag <<!<<<#if (isClosing) {#>>/<<#}#>><<=tagName>>>!>>
  emit genGenericTag(String tagName, boolean isClosing)(genericTag, cr);

  public void generate()
  {
    _genHeader(0, code);
    _genXMLTag(0, code);
    String name = "";
    StateMachine sm = null;
    
    // Verify that there is only one class that contains one state machine
    if (model.getUmpleClasses().size() == 1) {
      if (model.getUmpleClass(0).getStateMachines().size() == 1) {
        sm = model.getUmpleClass(0).getStateMachine(0);
        name = genTagAttribute("name", sm.getName());
      }
    }
    
    if (sm == null || isStateMachineEmpty(sm)) {
    	_genScxmlEmptyTag(0, code, name);
    	model.setCode(code.toString());
    	writeModel();
    	return;
    }
    
    _genScxmlOpeningTag(0, code, name);
    if (sm != null) {
      // Generate code for the state machine.
      for (State state : sm.getStates()) {
        generateState(state);
      }
    }
    
    // Look for additional methods inside the class and add them in a <script> in 
    // the scxml document.
    UmpleClass umpleClass = model.getUmpleClass(0);
    Boolean hasNonAutoGeneratedMethods = false;
    for (Method m : umpleClass.getMethods())
    {
      if (m.getSource() != Method.Source.fAutoAPI)
      {
        hasNonAutoGeneratedMethods = true;
        break;
      }
    }
    if (umpleClass.hasMethods() && hasNonAutoGeneratedMethods) {
      generateScxmlScript(umpleClass.getMethods());
    }
    
    _genScxmlClosingTag(0, code);
    model.setCode(code.toString());
    writeModel();
  }
  
  public boolean isStateMachineEmpty(StateMachine sm){
    UmpleClass parent = sm.getUmpleClass();
    return sm != null && !sm.hasStates() && !parent.hasMethods();
  }
    
  private void generateState(State state) {
  	if (isStateEmpty(state)) {
      _genStateEmptyTag(0, code, genTagAttribute("id", state.getName()));
      return;
    }
    
    _genStateOpeningTag(0, code, genTagAttribute("id", state.getName()));
    
    if (stateHasOnEntry(state)) {
      generateOnEntry(state);
    }
    
    if (stateHasOnExit(state)) {
      generateOnExit(state);
    }
    
    for (Transition transition: state.getTransitions()) {
      generateTransition(transition);
    }
    
    // Handle nested states.
    for (StateMachine nestedStateMachine : state.getNestedStateMachines()) {
      for (State subState : nestedStateMachine.getStates()) {
        generateState(subState);
      }
    }
     
    _genStateClosingTag(0, code);
  }
  
  private boolean isStateEmpty(State state) {
    return state != null && !state.hasTransitions() && !state.hasNestedStateMachines() && !state.hasActions();
  }
  
  private boolean stateHasOnEntry(State state) {
    if (state.hasActivities()) {
      return true;
    }
    
    for (Action action: state.getActions()) {
      if ("entry".equals(action.getActionType())) {
        return true;
      }
    }
    
    return false;
  }
  
  private boolean stateHasOnExit(State state) {
    for (Action action: state.getActions()) {
      if ("exit".equals(action.getActionType())) {
        return true;
      }
    }
    
    return false;
  }
  
  private void generateTransition(Transition transition) {
    String event = "";
    String cond = "";
    String target = genTagAttribute("target", transition.getNextState().getName());
    String type = "";
    
    if (transition.hasEvent()) {
      event = genTagAttribute("event", transition.getEvent().getName());
    }
    
    if (transition.hasGuard()) {
      Guard guard = transition.getGuard();
      JavaGenerator javaGenerator = new JavaGenerator();
      javaGenerator.setModel(model);
      cond = genTagAttribute("cond", guard.getCondition(javaGenerator));
    }
    
    if (isTransitionEmpty(transition)) {
    	_genTransitionTag(0, code, event, cond, target, type);
    	return;
   	}
   	
   	_genTransitionOpeningTag(0, code, event, cond, target, type);
   	
   	if (transition.hasAction()) {
   		generateTransitionAction(transition.getAction());
   	}
   	
   	_genTransitionClosingTag(0, code);
  }
  
  private boolean isTransitionEmpty(Transition transition) {
  	return transition != null && !transition.hasAction();
  }
  
  
  private void generateOnEntry(State state) {
    _genGenericTag(0, code, "onentry", false);
     
    for(Action action: state.getActions()) {
      _genGenericTag(0, code, "script", false);
      if ("entry".equals(action.getActionType())) {
        _genTextElement(0, code, action.getActionCode());
      }
      _genGenericTag(0, code, "script", true);
    }
     
    for (Activity activity: state.getActivities()) {
      _genGenericTag(0, code, "script", false);
      _genTextElement(0, code, activity.getActivityCode());
      _genGenericTag(0, code, "script", true);
      
      if (activity.hasOnCompletionEvent()) {
        Event cEvent = activity.getOnCompletionEvent();
        if (cEvent.isAutoTransition()) {
          String event = " event=\"" + cEvent.getName() + "\"";
          _genRaiseTag(0, code, event);
        }
      }
    } 
    
    _genGenericTag(0, code, "onentry", true);
  }
   
  private void generateOnExit(State state) {
    _genGenericTag(0, code, "onexit", false);
    _genGenericTag(0, code, "script", false);
    
    for (Action action: state.getActions()) {
      if ("exit".equals(action.getActionType())) {
        _genTextElement(0, code, action.getActionCode());
      }
    }
 	
    _genGenericTag(0, code, "script", true);
    _genGenericTag(0, code, "onexit", true);
  }
  
  private void generateTransitionAction(Action action) {
   	_genGenericTag(0, code, "script", false);
 	_genTextElement(0, code, action.getActionCode());
 	_genGenericTag(0, code, "script", true);
  }
  
   private void generateScxmlScript(List<Method> methods) {
     _genGenericTag(0, code, "script", false);
     
     for (Method method: methods) {
      if (method.getSource() == Method.Source.fAutoAPI)
        continue;
      _genTextElement(0, code, method.toString());  
     }
     
     _genGenericTag(0, code, "script", true);

   }

  private void writeModel()
  {
    try
    {
      String path = model.getUmpleFile().getPath();
      File file = new File(path);
      file.mkdirs();
      String modelFilename = path + File.separator + model.getUmpleFile().getSimpleFileName() + ".scxml";
      BufferedWriter bw = new BufferedWriter(new FileWriter(modelFilename));
      bw.write(model.getCode());
      bw.flush();
      bw.close();
    }
    catch (Exception e)
    {
      throw new UmpleCompilerException("There was a problem with generating SCXML code." + e, e);
    }
  }
}
