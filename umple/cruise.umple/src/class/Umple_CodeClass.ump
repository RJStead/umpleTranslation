namespace cruise.umple.compiler;

class UmpleModel {
  
  public UmpleClass addUmpleClass(String name)
  {
    UmpleClass newClass = getUmpleClass(name);
    if (newClass == null)
    {
      newClass = new UmpleClass(name, this);
      addUmpleClass(newClass);
    }
    return newClass;
  }
  public UmpleClass getUmpleClass(String name)
  {
    for (UmpleClass aClass : getUmpleClasses())
    {
        if (aClass.getName().equals(name))
        {
          return aClass;
        }
      }
      return null;
   }
   public UmpleInterface getUmpleInterface(String name)
   {
      for (UmpleInterface aInterface : getUmpleInterfaces())
      {
        if (aInterface.getName().equals(name))
        {
          return aInterface;
        }
      }
      return null;
    }
    
    private void addInterfacesRecursively(List interfacesToKeep, UmpleInterface anInterface) {
      interfacesToKeep.add(anInterface);
      for(UmpleInterface pi : anInterface.getExtendsInterface())
      {
        addInterfacesRecursively(interfacesToKeep, pi);
      }
    }
    mixset Association {
      public Association getAssociation(String name)
      {
        for (Association a : associations)
        {
          if (a.getName().equals(name))
          {
            return a;
          }
        }
        return null;
      }

      public AssociationClass addAssociationClass(String className)
      {
        AssociationClass newClass = (AssociationClass) getUmpleClass(className);
        if (newClass == null)
        {
          newClass = new AssociationClass(className);
          addUmpleClass(newClass);
        }
        return newClass;
      }
    }


  mixset Association {
/*
 */
  class AssociationClass
  {
    public AssociationClass(String name)
    {
      this(name, null);
    }

    public void addMissingKeyIfNeeded()
    {
      Key key = getKey();
      if (!key.isProvided())
      {
        key = new Key();

        for(Association associatedTo: getAssociatedTo())
        {
          key.addMember(associatedTo.getEnd(1).getRoleName());
        }

        key.setIsInternal(true);
        setKey(key);
      }
      }
    }
  } 
}

/*
 * In Umple_Code.ump: Methods for computing complex properties
 */
class UmpleClass
{

  public Method getAutoGeneratedConstructor()
  {
  	for (Method aMethod : this.getMethods())
  	{
  		if (aMethod.getIsConstructor())
  		{
  			return aMethod;
  		}
  	}
  	return null;
  }
mixset Trait {
  public boolean hasMethodInTraits (Method aMethod) {
	  for (UmpleTrait uTrait : getExtendsTraits()) {
		  if (uTrait.hasCascadeMethod(aMethod,true) || uTrait.hasCascadeMethod(aMethod,false)) {
			  return true;
		  }
	}
	  return false;
  }
}

  after setExtendsClass {
    if(aExtendsClass!=null&&aExtendsClass.getMethods()!=null)
    for(Method method:aExtendsClass.getMethods())
    {
      if(this.hasMethod(method))
      {
        Method aMethod = this.getMethod(method);

        if(aMethod.getMethodBody().getExtraCode("")==null||"".equals(aMethod.getMethodBody().getExtraCode("")))
        {
          aMethod.getMethodBody().setExtraCode("",method.getMethodBody().getExtraCode(""));
          while(aMethod.hasMethodParameters())
          {
            aMethod.removeMethodParameter(aMethod.getMethodParameter(0));
          }
          for(MethodParameter mp:method.getMethodParameters())
          {
            aMethod.addMethodParameter(mp);
          }
          if(!"".equals(aMethod.getMethodBody().getExtraCode("")))
          {
            aMethod.setIsImplemented(false);
          }
        }
      }
    }
  }

  public UmpleClass(String name)
  {
    this(name, null);
  }
  mixset Trace {
  public List<TraceDirective> getAllTraceDirectives(){
    ArrayList<TraceDirective> all = new ArrayList<TraceDirective>();
    all.addAll(getTraceDirectives());

    for(TraceCase tc : getTraceCases())
      if( tc.getActivation() ==  true )
        for(TraceDirective td : tc.getTraceDirectives())
          all.add(td);

    return all;
  }
  }

  public ArrayList<String> getMethodNames()
  {
    ArrayList<String> methodNames = new ArrayList<String>();
    for(Attribute attr : this.getAttributes())
    {
      methodNames.addAll(attr.getMethodNames());
    }

    for(AssociationVariable av : this.getAssociationVariables())
    {
      methodNames.addAll(av.getMethodNames());
    }
    mixset StateMachine {
      for(StateMachine sm : this.getStateMachines())
      {
        String stateMachineName = sm.getName().substring(0, 1).toUpperCase() + sm.getName().substring(1);
        methodNames.add("set" + stateMachineName);
        methodNames.add("get" + stateMachineName);

        for(Event ev : sm.getEvents())
        {
          methodNames.add(ev.getName());
        }
      }
    }
    for (Method m: this.getMethods()) {
      if (!isGetterSetter(m) && !m.isIsConstructor()) {
        methodNames.add(m.getName());
      }
    }

    methodNames.add("constructor");
    methodNames.add("delete");
    methodNames.add("toString");

    return methodNames;
  }
  
    // line 1869 "../../../../src/class/UmpleInternalParser_CodeClass.ump"
   private boolean isGetterSetter(Method method){
    if (method.getName().length() <= 2)
  		return false;
    String accessorName = method.getName().substring(0,3);
  	return ((accessorName.equals("get")) || (accessorName.equals("set"))) && method.getSource() == Method.Source.fAutoAPI && !method.getIsConstructor();
  }

  public Boolean matchOperationMethod(String fullOperation, String method) {
    String formattedMethod = method;
    TriState isMatch = new TriState(false);
    TriState isMatchOnExclude = new TriState(true);

    String[] allOperations = fullOperation.split(",");
    for (String operation : allOperations)
    {
      boolean isNot = false;
      if (operation.startsWith("!"))
      {
        isNot = true;
        operation = operation.substring(1);
      }

      String regexOperation = operation;
      regexOperation = regexOperation.replace("_*", "*");
      regexOperation = regexOperation.replace("*", ".*");
      boolean isCurrentMatch = formattedMethod.matches(regexOperation);

      if (isNot && isCurrentMatch)
      {
        isMatch.setStatus(false);
        isMatchOnExclude.setStatus(false);
      }
      else if (!isNot && isCurrentMatch)
      {
        isMatch.setStatus(true);
      }
    }

    return isMatchOnExclude.isTrue() || isMatch.isTrue();
  }

  // Gets applicable code injectiosn for generated methods
  public List<CodeInjection> getApplicableCodeInjections(String type, String method)
  {
    ArrayList<CodeInjection> all = new ArrayList<CodeInjection>();
    if (type == null || method == null)
    {
      return all;
    }

    String formattedMethod = method;

    for (CodeInjection code : getCodeInjections())
    {
      if (code.getOperation() == null || !type.equals(code.getType()) || !("all".equals(code.getOperationSource()) || "generated".equals(code.getOperationSource())))
      {
        continue;
      }

      boolean isAllExcludes = true;
      TriState isMatch = new TriState(false);
      TriState isMatchOnExclude = new TriState(true);

      String[] allOperations = code.getOperation().split(",");
      for (String operation : allOperations)
      {

        boolean isNot = false;
        if (operation.startsWith("!"))
        {
          isNot = true;
          operation = operation.substring(1);
        }
        else
        {
          isAllExcludes = false;
        }
        isMatchOnExclude.setIsSet(true);

        String regexOperation = operation;
        regexOperation = regexOperation.replace("_*", "*");
        regexOperation = regexOperation.replace("*", ".*");
        boolean isCurrentMatch = formattedMethod.matches(regexOperation);

        if (isNot && isCurrentMatch)
        {
          isMatch.setStatus(false);
          isMatchOnExclude.setStatus(false);
        }
        else if (!isNot && isCurrentMatch)
        {
          isMatch.setStatus(true);
        }
      }

      if ((isAllExcludes && isMatchOnExclude.isTrue()) || isMatch.isTrue())
      {
        all.add(code);
      }
    }

    return all;
  }

  // Gets applicable code injectiosn for custom defined methods
  public List<CodeInjection> getApplicableCodeInjectionsCustomMethod(String type, String method, List<MethodParameter> parameters)
  {
    ArrayList<CodeInjection> all = new ArrayList<CodeInjection>();
    if (type == null || method == null)
    {
      return all;
    }

    String formattedMethod = method;
    for (CodeInjection code : getCodeInjections())
    {
      if (code.getOperation() == null || !type.equals(code.getType()) || !("all".equals(code.getOperationSource()) || "custom".equals(code.getOperationSource())))
      {
        continue;
      }

      boolean isAllExcludes = true;
      TriState isMatch = new TriState(false);
      TriState isMatchOnExclude = new TriState(true);

      String[] allOperations = code.getOperation().split(",");
      for (int opInd = 0; opInd < allOperations.length; opInd++)
      {
        String operation = allOperations[opInd];

        boolean isNot = false;
        if (operation.startsWith("!"))
        {
          isNot = true;
          operation = operation.substring(1);
        }
        else
        {
          isAllExcludes = false;
        }
        isMatchOnExclude.setIsSet(true);

        String regexOperation = operation;
        regexOperation = regexOperation.replace("_*", "*");
        regexOperation = regexOperation.replace("*", ".*");
        regexOperation = regexOperation.replace("_~", "");
        boolean isCurrentMatch = formattedMethod.matches(regexOperation);

        boolean isParameterMatch = true;
        String currentParameters = code.getParameters()[opInd];

        if((parameters.size() == 0 && "".equals(currentParameters)) || "...".equals(currentParameters)) {
          isParameterMatch = true;
        }
        else if(parameters.size() != currentParameters.split(",").length)
        {
          isParameterMatch = false;
        } 
        else {
          int indx = 0;
          for(String parameterType : currentParameters.split(",")) {
            if(!parameterType.equals(parameters.get(indx).getType())) {
              isParameterMatch = false;
            }
            indx++;
          }
        } 

        isCurrentMatch &= isParameterMatch;

        if (isNot && isCurrentMatch)
        {
          isMatch.setStatus(false);
          isMatchOnExclude.setStatus(false);
        }
        else if (!isNot && isCurrentMatch)
        {
          isMatch.setStatus(true);
        }
      }

      if ((isAllExcludes && isMatchOnExclude.isTrue()) || isMatch.isTrue())
      {
        all.add(code);
      }
    }

    return all;
  }

  public void addReferencedPackage(String aNamespace)
  {
    if (indexOfNamespace(aNamespace) == -1 && !aNamespace.equals(getPackageName()))
    {
      addNamespace(aNamespace);
    }
  }

  // It can happen that one class has multiple association variables with the same name
  public AssociationVariable getAssociationVariable(String className, String roleName)
  {
    for (AssociationVariable av : associationVariables)
    {
      if (av.getName().equals(roleName) && av.getType().equals(className))
      {
        return av;
      }
    }
    return null;
  }

  public AssociationVariable getAssociationVariable(String name)
  {
    for (AssociationVariable av : associationVariables)
    {
      if (av.getName().equals(name))
      {
        return av;
      }
    }
    return null;
  }

  public AssociationVariable getAssociationVariableFor(UmpleClass uClass)
  {
    for (AssociationVariable av : associationVariables)
    {
      if (av.getType().equals(uClass.getName()))
      {
        return av;
      }
    }
    return null;
  }

  public boolean hasImplementedMethodIncludingWithinParentClasses(Method comparedMethod) {
    Method aMethod = getMethod(comparedMethod);
    if(aMethod!=null&&!aMethod.isIsAbstract()){
      return true;
    }
    mixset StateMachine {
    if (numberOfStateMachines()>0){
    	for(StateMachine sm : getStateMachines()){
    		if (sm.getEventByMethod(comparedMethod)!=null){
    			return true;
    		}
    	}
    }
    }
    if(getExtendsClass()!=null&&getExtendsClass().hasImplementedMethodIncludingWithinParentClasses(comparedMethod)){
      return true;
    }
    return false;
  }
  
  //Issue 771
  public boolean hasSameType(Method comparedMethod){
    String methodType = comparedMethod.getType();
    for (Method aMethod : this.getMethods()){
    	if(aMethod.getType().equals(methodType)){
    		return true;
    	}
    }
    return false;
  }
  

  public Method getMethod(Method comparedMethod){
    String methodName = comparedMethod.getName();
    int numberOfParams = comparedMethod.getMethodParameters().size();
    for (Method aMethod : this.getMethods()){
      // Compare method names
      if (aMethod.getName().equals(methodName)){
        // Now compare parameters
        if (numberOfParams == aMethod.getMethodParameters().size())
        {
          boolean allSame = true;
          for (int i = 0; i < numberOfParams; i++)
          {
            if(!aMethod.getMethodParameter(i).getType().equals(comparedMethod.getMethodParameter(i).getType()))
            {
              allSame = false;
              break;
            }
          }
          if(allSame)
          {
            return aMethod;
          }
        }
      }
    }
    return null;
  }

  public boolean hasAllAttributes()
  {
    return getAllAttributes().size() > 0;
  }

  public List<Attribute> getAllAttributes()
  {
    List<Attribute> all = new ArrayList<Attribute>();

    // Get all it's inherited attributes
    if (this.hasExtendsClass()) {
      UmpleClass parent = this.getExtendsClass();
      List<Attribute> allParent = parent.getAllAttributes();
      all.addAll(allParent);
    }

    all.addAll(getAttributes());

    return all;
  }

  public Attribute getAttribute(String name)
  {
    for (Attribute av : getAllAttributes())
    {
      if (av.getName().equals(name))
      {
        return av;
      }
    }
    return null;
  }

  public boolean isRoot()
  {
    return extendsClass == null;
  }

  protected GeneratedClass gClass = null;
  public GeneratedClass getGeneratedClass()
  {
    return gClass;
  }

  public GeneratedClass createGeneratedClass(UmpleModel model)
  {
    gClass = new GeneratedClass(model, this);
    if (getExtendsClass() != null)
    {
      gClass.setParentClass(getExtendsClass().getGeneratedClass());
    }
    return getGeneratedClass();
  }

  public boolean isAttributeClass()
  {
    for (AssociationVariable association : getAssociationVariables())
    {
      if (association.getIsNavigable())
      {
        return false;
      }
    }
    return true;
  }

  /* @return true if this class is immutable, either because it has the "immutable" modifier or
   * because an ancestor class is immutable; false if this class neither has the "immutable" modifier
   * nor an immutable ancestor.
   */
  public boolean isImmutable()
   {
     return (iAmImmutable || ancestorIsImmutable);
  }

  public boolean setImmutable()
  {
    boolean wasSet = false;
    if (extendsClass != null && !ancestorIsImmutable) { return wasSet; }

    if (propagateImmutabilityToAllRelationships(true))
    {
      iAmImmutable = true;
      wasSet = true;
    }
    return wasSet;
  }

 internal const Integer CounterLimit = 25; //Arbitary Limit
 Integer propagateCounter = CounterLimit; 
 
  private boolean propagateImmutabilityToAllRelationships(boolean isImmutable)
  {
    setPropagateCounter(getPropagateCounter() - 1); //Reduce by 1 for each call
    
    if (isImmutable)
    {
      mixset StateMachine {
      if (this.hasStateMachines()) { return false; }
      }

      for (AssociationVariable av : associationVariables)
      {
        if (!immutabilityAssociationRulesSatisfied(av, true)) { return false; }
      }
    }

    if( getPropagateCounter() == 0 ) {
        setPropagateCounter(CounterLimit);
        return true;
    }
    else{
      return notifySubclassesAncestorImmutable(isImmutable);
    }
  }

  private boolean notifySubclassesAncestorImmutable(boolean isImmutable)
  {
    boolean notified = true;
    List<UmpleClass> wereSet = new ArrayList<UmpleClass>();
    for (UmpleClass subclass : getSubclasses())
    {
      notified = subclass.setAncestorIsImmutable(isImmutable);
      if (!notified)
      {
        for (UmpleClass wasSet : wereSet)
        {
          wasSet.setAncestorIsImmutable(!isImmutable);
        }
        return notified;
      }
    }
    return notified;
  }

  protected boolean setAncestorIsImmutable(boolean isImmutable)
  {
    if (iAmImmutable)
    {
      ancestorIsImmutable = isImmutable;
      return true;
    }
    else
    {
      boolean success = propagateImmutabilityToAllRelationships(isImmutable);
      if (success) { ancestorIsImmutable = isImmutable; }
      return success;
    }
  }

  private boolean enforceImmutabilityInheritanceRules(UmpleClass newSuperClass)
  {
    // A subclass may not be immutable if the superclass is not immutable
    if (iAmImmutable && newSuperClass != null && !newSuperClass.isImmutable()) { return false; }
    boolean ancestorImmutable = (newSuperClass == null) ? false : newSuperClass.isImmutable();
    return setAncestorIsImmutable(ancestorImmutable);
  }

  protected static boolean immutabilityAssociationRulesSatisfied(AssociationVariable myAV, UmpleClass myClass, boolean myClassImmutable,
      AssociationVariable yourAV, UmpleClass yourClass, boolean yourClassImmutable)
  {
    boolean satisfied = false;
    if (myAV == null || yourAV == null)
    {
      satisfied = true;
    }
    else if (!myClassImmutable && !yourClassImmutable && !"immutable".equals(myAV.getModifier()) && !"immutable".equals(yourAV.getModifier()))
    {
      satisfied = true;
    }
    else if (myAV.getIsNavigable() && yourAV.getIsNavigable())
    {
      //satisfied = false;
    }
    else if (myClass == null && yourClass == null)
    {
      satisfied = true;
    }
    else if (!yourAV.getIsNavigable() && (yourClass == null || yourClassImmutable))
    {
      if (yourClass != null && yourClass == myClass && myAV.isMandatory())
      {
        // reflexive associations may not be mandatory:
        //satisfied = false
      }
      else
      {
        satisfied = true;
      }
    }
    else if (!myAV.getIsNavigable() && (myClass == null || myClassImmutable))
    {
      if (myClass != null && yourClass == myClass && yourAV.isMandatory())
      {
        // reflexive associations may not be mandatory:
        //satisfied = false
      }
      else
      {
        satisfied = true;
      }
    }
    return satisfied;
  }

  protected boolean immutabilityAssociationRulesSatisfied(AssociationVariable myAV, boolean myClassImmutable)
  {
    AssociationVariable relatedAV = myAV.getRelatedAssociation();
    UmpleClass relatedClass = (relatedAV == null) ? null : relatedAV.getUmpleClass();
    boolean relatedClassImmutable = (relatedClass == null) ? false : ((relatedClass == this) ? myClassImmutable : relatedClass.isImmutable());

    return immutabilityAssociationRulesSatisfied(myAV, this, myClassImmutable, relatedAV, relatedClass, relatedClassImmutable);
  }


  public boolean deleteAttribute(Attribute aAttribute)
  {
    boolean wasRemoved = false;
    //Unable to remove aAttribute, as it must always have a umpleClass
    if (this.equals(aAttribute.getUmpleClass()))
    {
      attributes.remove(aAttribute);
      wasRemoved = true;
    }
    return wasRemoved;
  }
  
  
  public void removeAllAutoGeneratedMethods()
  {
    List<Method> methodsCopy = new ArrayList<Method>(this.getMethods());
  	for (Method m: methodsCopy)
  	{
  		if (m.getSource() == Method.Source.fAutoAPI)
  			removeMethod(m);
  	}
  }

  public void removeAutoGenerateMethodsForAttribute(Attribute attribute)
  {
  	String attributeName = attribute.getName();
  	String firstLetter = attributeName.substring(0,1).toUpperCase();
  	String rest = "";
  	if (attributeName.length() > 1)
  	{
  		rest = attributeName.substring(1);
  	}
  	String getName = "get" + firstLetter + rest;
  	String setName = "set" + firstLetter + rest;
  	
  	List<Method> methodsCopy = new ArrayList<Method>(this.getMethods());
    
    for (Method m : methodsCopy)
    {
    	if (m.getName().equals(getName) && m.getMethodParameters().size() == 0)
    		removeMethod(m);
    	else if (m.getName().equals(setName) && m.getMethodParameters().size() == 1
    			&& m.getMethodParameter(0).getType().equals(attribute.getType()))
    		removeMethod(m);
    }
  }
  
  public void removeAttributeFromAutogeneratedConstructor(Attribute aAttribute)
  {
  	Method constructor = this.getAutoGeneratedConstructor();
  	if (constructor != null)
  	{
  		String attributeName = aAttribute.getName();
  		String parameterName = "a" + attributeName.substring(0,1).toUpperCase();
  		if (attributeName.length() > 1)
  		{
  			parameterName += attributeName.substring(1);
  		}
  	
  		MethodParameter toRemove = null;
  	
  		for (MethodParameter mp : constructor.getMethodParameters())
  		{
  			if (mp.getName().equals(parameterName) && mp.getFullType().equals(aAttribute.getType()))
  			{
  				toRemove = mp;
  				break;
  			}
  		}
  		
  		if (toRemove != null)
  		{
  			constructor.removeMethodParameter(toRemove);
  		}
  	}  	
  }
  
  after removeAttribute {
  	if (wasRemoved)
  	{
  		this.removeAttributeFromAutogeneratedConstructor(aAttribute);
  	}
  }
  
  // Issue 1008 - Helper function to determine if the Umple Class has a particular enumeration
  public boolean hasEnum(String enumName) {
    for (UmpleEnumeration uEnum : getEnums()) {
      if (uEnum.getName().equals(enumName)) {
        return true;
      }
    }
    return false;
  }

}
