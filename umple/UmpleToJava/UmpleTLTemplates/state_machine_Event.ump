class UmpleToJava {
    state_machine_Event <<!<</*state_machine_Event*/>><<#
  
  // Issue 923 Fix: Prevent default implmentation of interface methods when a state machine implements them
  boolean implementsInterfaceMethod = false;
  for (UmpleInterface uInterface : uClass.getParentInterface())
  {
  	for (Method m : uInterface.getMethods())
  	{
  		Method eventMethod = new Method("",e.getName(),e.getType().toLowerCase(),false);
  		eventMethod.setMethodParameters(e.getParams());
  		if (m.compareWithTheMethod(eventMethod))
  		{
  			uClass.removeMethod(m);
  			implementsInterfaceMethod = true;
  			break;
  		}
  	}
  	
  	if (implementsInterfaceMethod)
  	{
  		break;
  	}
  }
  
  int javaLine = realSb.toString().split("\\n").length+7;

  StringBuilder allCases = new StringBuilder();
  StringBuilder allDeclarations = new StringBuilder();
  
  StringBuilder actionLineNumbers = new StringBuilder();
  StringBuilder actionFileNames = new StringBuilder();
  StringBuilder actionJavaLineNumbers = new StringBuilder();
  StringBuilder actionLengths = new StringBuilder();
  String umpleSourceFileFormat = "\n  @umplesourcefile(line={{0}}, file={{1}}, javaline={{2}}, length={{3}})";
  String customEventPrefixCode = GeneratorHelper.toCode(uClass.getApplicableCodeInjections("before", gen.translate("eventMethod",e)));
  String customEventPostfixCode = GeneratorHelper.toCode(uClass.getApplicableCodeInjections("after", gen.translate("eventMethod",e)));
  if(e.getName().startsWith("_")&&(customEventPrefixCode==null||customEventPostfixCode==null))
  {
    boolean queued = false;
    for(StateMachine sm : uClass.getStateMachines(e))
    {
      if(sm.isQueued())
      {
        queued = true;
        break;
      }
    }
    if(queued)
    {
      if(customEventPrefixCode==null)
      {
        customEventPrefixCode = GeneratorHelper.toCode(uClass.getApplicableCodeInjections("before", gen.translate("eventMethod",e)));
      }
      if(customEventPostfixCode==null)
      {
        customEventPostfixCode = GeneratorHelper.toCode(uClass.getApplicableCodeInjections("after", gen.translate("eventMethod",e)));
      }
  
    }
  }
  for(StateMachine sm : uClass.getStateMachines(e))
  {
    allDeclarations.append(StringFormatter.format("\n    {0} {1} = {2};",gen.translate("type",sm),gen.translate("parameterOne",sm),gen.translate("stateMachineOne", sm)));
    if(sm.getContainsHistoryState())
    {     
      allDeclarations.append(StringFormatter.format("\n    if ({0} != {1}.Null){",gen.translate("stateMachineOne",sm),gen.translate("type",sm)));
    	allDeclarations.append(StringFormatter.format("{0}H = {1};}",gen.translate("stateMachineOne",sm),gen.translate("stateMachineOne", sm)));    
      javaLine++;
    }
    if(sm.getContainsDeepHistoryState())
    { 
      allDeclarations.append(StringFormatter.format("\n    if ({0} != {1}.Null){",gen.translate("stateMachineOne",sm),gen.translate("type",sm)));
    	allDeclarations.append(StringFormatter.format("{0}HStar = {1};}",gen.translate("stateMachineOne",sm),gen.translate("stateMachineOne", sm)));
      javaLine++;
    }
    allCases.append(StringFormatter.format("\n    switch ({0})\n",gen.translate("parameterOne",sm)));
    allCases.append(StringFormatter.format("    {\n"));
    javaLine+=3;
    
    // Issue 935 - Need to retrieve the super state machine and have transitions first make a call it's exit method to perform an external transition
    StateMachine superStateMachine = sm.getSuperStateMachine();
    State nullState = sm.getNullState();
    boolean transitionIsAndCross = false;
    
    for(State state : sm.getStates())
    {
  	  TraceItem traceItem = state.getTraced("transition",uClass);
      List<Transition> allT = state.getTransitionsFor(e);
  
      if (allT.size() == 0)
      {
        continue;
      }

      allCases.append(StringFormatter.format("      case {0}:\n",gen.translate("stateOne",state)));
      javaLine++;

      boolean needsBreak = true;
      for (Transition t : allT)
      {
        
        State nextState = t.getNextState();
        String tabSpace = t.getGuard() == null ? "        " : "          ";
        
        String condition = t.getGuard()!=null?gen.translate("Open",t.getGuard()):"if ()\n{";
        if (!"if ()\n{".equals(condition))
        {
          StateMachine sm_temp=sm;
          if (sm.getUmpleClass()==null) sm_temp=sm.getRootStateMachine();
          
          addUncaughtExceptionVariables(gen.translate("eventMethod",e),
                                      sm_temp.getUmpleClass().getRelativePath(t.getGuard().getPosition().getFilename(),"Java").replace("\\","/").replaceAll(".*/","").replace("\"",""),
                                      t.getGuard().getPosition().getLineNumber(),
                                      javaLine-1,
                                      condition.split("\\n").length-1);
          allCases.append(GeneratorHelper.doIndent(condition, "        ")+"\n");
          javaLine+=1+condition.split("\\n").length;
          
        }
        
        // Issue 935
        State concurrentParent = null;
        if (state != nullState && state.getHasExitAction()) 
        {
          // Concurrent state machines require additional handling
          State fromConcurrentParentState = state.getConcurrentParentState();
          if (fromConcurrentParentState != null) {
            StateMachine concurrentSmToExit = null;
      
            if (nextState.getStateMachine().equals(superStateMachine)) {
              concurrentSmToExit = superStateMachine;
            } else if (state.getStateMachine().equals(nextState.getStateMachine())) {
              concurrentSmToExit = state.getStateMachine();
            } else {
              State nextConcurrentParentState = nextState.getConcurrentParentState();
              concurrentSmToExit = t.getSmToExit(superStateMachine);
              if (nextConcurrentParentState != null) {
                if (fromConcurrentParentState.equals(nextConcurrentParentState)) {
                  if (t.isTransitionAndCross(fromConcurrentParentState)) {
                    concurrentParent = fromConcurrentParentState;
                    transitionIsAndCross = true;
                  }
                }
              }
            }
            
            allCases.append(StringFormatter.format("{0}{1}();\n",tabSpace,gen.translate("exitMethod",concurrentSmToExit))); 
          } else {
            StateMachine smToExit = t.getSmToExit(superStateMachine);
            allCases.append(StringFormatter.format("{0}{1}();\n",tabSpace,gen.translate("exitMethod",smToExit))); 
          }
          javaLine++;
        }
        
        if (t.getAction() != null)
        {
          Action a1 = t.getAction();
          Position p = a1.getPosition();
          if (p != null) {
          
            StateMachine sm_temp=sm;
            if (sm.getUmpleClass()==null) sm_temp=sm.getRootStateMachine();
            
            final String relativePath = sm_temp.getUmpleClass().getRelativePath(p.getFilename(),"Java");
            
            addUncaughtExceptionVariables(gen.translate("eventMethod",e),
                                        relativePath.replace("\\","/").replaceAll(".*/","").replace("\"",""),
                                        p.getLineNumber(),
                                        javaLine-2,
                                        a1.getActionCode().split("\\n").length);
            allCases.append("        // line " + p.getLineNumber() + " \"" + relativePath + "\"\n");
            javaLine++;
          }
          allCases.append(StringFormatter.format("{0}{1}\n",tabSpace,a1.getActionCode()));
          javaLine+=a1.getActionCode().split("\\n").length;
        }
        
        StateMachineTraceItem traceStmItem = null;
        
        traceStmItem = state.getTrace("entry",uClass,t);
        allCases.append(traceStmItem!=null?traceStmItem.trace(gen, t, "sm_t", uClass)+"\n":"");
        
        traceStmItem = state.getTrace("exit",uClass,t);
        allCases.append(traceStmItem!=null?traceStmItem.trace(gen, t, "sm_t", uClass)+"\n":"");
        
        traceStmItem = state.getTrace("state",uClass,t);
        allCases.append(traceStmItem!=null?traceStmItem.trace(gen, t, "sm_t", uClass)+"\n":"");
        
        traceStmItem = state.getTrace("transition",uClass,t);
        allCases.append(traceStmItem!=null?traceStmItem.trace(gen, t, "sm_t", uClass)+"\n":"");
        	
//        allCases.append(traceItem!=null&&traceItem.getIsPre()?traceItem.trace(gen, t,"sm_t", uClass)+"\n":"");
        if (nextState.getIsHistoryState() == true)
        {
        	allCases.append(StringFormatter.format("{0}{1}({2}{3});\n",tabSpace,gen.translate("setMethod",nextState.getStateMachine()),gen.translate("stateMachineOne",nextState.getStateMachine()),gen.translate("stateOne",nextState)));
        	
        }
        else
        {
        	allCases.append(StringFormatter.format("{0}{1}({2}.{3});\n",tabSpace,gen.translate("setMethod",nextState.getStateMachine()),gen.translate("type",nextState.getStateMachine()),gen.translate("stateOne",nextState)));
		}

        // Issue 935 - Additional processing for concurrent state machines
        if (transitionIsAndCross) {
          for (StateMachine smToReset : concurrentParent.getNestedStateMachines()) {
            if (smToReset.indexOfState(state) != -1) {
              allCases.append(StringFormatter.format("{0}{1}({2}.{3});\n",tabSpace,gen.translate("setMethod", smToReset),gen.translate("type", smToReset),gen.translate("stateOne", smToReset.getStartState())));
              break;
            } else {
              boolean reset = false;
              for(StateMachine nestedStateMachine : smToReset.getNestedStateMachines()) {
                if (nestedStateMachine.indexOfState(state) != -1) {
                  reset = true;
                  break;
                }
              }
              if (reset) {
                allCases.append(StringFormatter.format("{0}{1}({2}.{3});\n",tabSpace,gen.translate("setMethod", smToReset),gen.translate("type", smToReset),gen.translate("stateOne", smToReset.getStartState())));
                break;
              }
            }
          }
        }
//        allCases.append(traceItem!=null&&traceItem.getIsPost()?traceItem.trace(gen, t,"sm_t", uClass)+"\n":"");

        
        allCases.append(StringFormatter.format("{0}wasEventProcessed = true;\n",tabSpace));
        allCases.append(StringFormatter.format("{0}break;\n",tabSpace));
        
        javaLine+=traceItem!=null?4:3;
        
        if (!"if ()\n{".equals(condition))
        {
          allCases.append(StringFormatter.format("        }\n"));
          javaLine++;
        }
        else
        {
          needsBreak = false;
          //You can only have one *no guard case*
          break;
        }
      }
  
      if (needsBreak)
      {
        allCases.append(StringFormatter.format("        break;\n"));
        javaLine++;
      }
    } 
    allCases.append(StringFormatter.format("      default:\n"));
    allCases.append(StringFormatter.format("        // Other states do respond to this event\n"));
    
    for(State s : sm.getStates())
    {
      Transition t1=null;
      Transition t2=null;
      String exitEvent=null;
      if (sm.getParentState() != null)
      {
        State parentState = sm.getParentState();
        exitEvent = gen.translate("exitMethod",parentState);
      }
      for(Transition tran: s.getTransitions())
      {
        if(tran.getEvent().isUnspecified())
        {
          t1=tran;
        }
        if(tran.getEvent().getName().equals(e.getName()))
        {
          t2=tran;
        }
      }
      if(s.getTransitions().contains(t1) && s.getTransitions().contains(t2))
      {
        if(!e.isUnspecified() && !e.getName().equals(exitEvent))
        {
          allCases.append(StringFormatter.format("        wasEventProcessed = unspecified("));
          allCases.append(StringFormatter.format("get"));
          allCases.append(StringFormatter.format("{0}",gen.translate("type",sm)));
          allCases.append(StringFormatter.format("("));
          allCases.append(StringFormatter.format(").toString()"));
          allCases.append(StringFormatter.format(", "));
          allCases.append(StringFormatter.format("\""));
          allCases.append(StringFormatter.format(e.getName()));
          allCases.append(StringFormatter.format("\""));
          allCases.append(StringFormatter.format(");\n"));
        }
      }
    }
    allCases.append(StringFormatter.format("    }\n"));
    javaLine+=3;
  }

  String override =  (implementsInterfaceMethod) ? "@Override\n" : "";
  String scope = e.getIsInternal() || e.isAutoTransition() ? "private" : "public";
  if (implementsInterfaceMethod)
  {
  	scope = "  " + scope;
  }
  String eventOutput = allDeclarations.toString() + allCases.toString();#>>
  <<= override >><<= scope >> boolean <<#for (StateMachine sm : uClass.getStateMachines()){if((sm.isQueued() && e.getIsInternal() == false && e.isAutoTransition() == false && !e.isUnspecified()) || (sm.isPooled() && e.getIsInternal() == false && e.isAutoTransition() == false && !e.isUnspecified())){append(realSb,"_");}break;}#>><<=gen.translate("eventMethod",e)>>(<<= (e.getArgs()==null?"":e.getArgs())>><<#if(e.isUnspecified()){append(realSb,"String state, String event");}#>>)
  {<<# if (customEventPrefixCode != null) { addUncaughtExceptionVariables(realSb.toString().split("\\n").length,customEventPrefixCode,gen.translate("eventMethod",e));
    append(realSb, "\n{0}",GeneratorHelper.doIndent(customEventPrefixCode, "    ")); } #>>
    boolean wasEventProcessed = false;
    <<= eventOutput >><<# if (customEventPostfixCode != null) { addUncaughtExceptionVariables(realSb.toString().split("\\n").length,customEventPostfixCode,gen.translate("eventMethod",e)); 
    append(realSb, "\n{0}",GeneratorHelper.doIndent(customEventPostfixCode, "    ")); } #>>
    return wasEventProcessed;
  }
!>>
}
