class UmpleToRuby {
    class_MethodDeclaration <<!<</*class_MethodDeclaration*/>><<#
  // don't recheck for method being present: 
  // the for loop will terminate immediately even if there are none with little to no 
    for (Method aMethod : uClass.getMethods())
  	{
      if (aMethod.getSource() == Method.Source.fAutoAPI)
        continue;
      String methodName = aMethod.getName();
      String methodType = aMethod.getType();
      String customBeforeInjectionCode = GeneratorHelper.toCode(uClass.getApplicableCodeInjectionsCustomMethod("before", aMethod.getName(), aMethod.getMethodParameters()));
      String customAfterInjectionCode  = GeneratorHelper.toCode(uClass.getApplicableCodeInjectionsCustomMethod("after", aMethod.getName(), aMethod.getMethodParameters()));
      String customPreconditionCode = GeneratorHelper.toCode(uClass.getApplicableCodeInjections("before", aMethod.getName()+"Precondition"));
      String customPostconditionCode = GeneratorHelper.toCode(uClass.getApplicableCodeInjections("before", aMethod.getName()+"Postcondition"));
      customPostconditionCode = customPostconditionCode==null?"":customPostconditionCode;
        
      String methodBody;
      if (aMethod.getIsAbstract()) {
       methodBody = "fail NotImplementedError, \"Method, " + uClass.getName() + "." + methodName + ", must be implemented.\"";
      } else {
       methodBody = (aMethod.getMethodBody() != null) ? aMethod.getMethodBody().getExtraCode() : "";
      }

      String properMethodBody = "    " + methodBody;
      String finalParams = "";
      StringBuilder parameters = new StringBuilder();
      if (aMethod.hasMethodParameters())
      {
        for (MethodParameter aMethodParam : aMethod.getMethodParameters()) 
        {
          String paramName = aMethodParam.getName();
          String aSingleParameter = paramName;
          parameters.append(aSingleParameter + ", ");
        }
        finalParams = parameters.toString().substring(0, parameters.toString().length()-2);
      }
        
      appendln(realSb, "");
      	
      if (aMethod.numberOfComments() > 0) { append(realSb, "\n  {0}\n", Comment.format("RubyMultiline Internal", aMethod.getComments())); }
    	
      append(realSb, "  def {0} ({1})\n", methodName, finalParams);
      
      if(!"".equals(customPostconditionCode))
      {
        if(!"".equals(methodType)&&!"void".equals(methodType)){
          append(realSb, "    result = {0}_original({1})\n", methodName, finalParams);
        }
        else {
          append(realSb, "    {0}_original({1})\n", methodName, finalParams);
        }
        appendln(realSb, GeneratorHelper.doIndent(customPostconditionCode, "    "));
        if(!"".equals(methodType)&&!"void".equals(methodType)){
          append(realSb, "    return result\n");
        }          
        appendln(realSb, "  end");
        append(realSb, "\n  def {0}_original({1})\n", methodName, finalParams);
      }
    	
      if (customPreconditionCode != null) { append(realSb, "\n{0}\n",GeneratorHelper.doIndent(customPreconditionCode, "    "));}
      if (customBeforeInjectionCode != null) { append(realSb, "{0}\n",GeneratorHelper.doIndent(customBeforeInjectionCode, "    "));}

      if(properMethodBody.contains("return")) {
        if(customAfterInjectionCode != null) {
          // Do some pre-processing to handle returns not being on a new line. Doing this allows us to maintain suitable indentation.
          String[] properMethodLines = properMethodBody.split("\\n");
          String fixedProperMethodBody = "";
          for(int i = 0; i < properMethodLines.length; i++) {
            if(GeneratorHelper.isValidReturnStatement(properMethodLines[i]) && !properMethodLines[i].trim().substring(0, 6).equals("return")) {
              String[] splitLines = properMethodLines[i].split("return", 2);
              // Determine indentation of return by adding indentation amount to previous line
              String returnIndent = "";
              int j = 0;
              while(splitLines[0].charAt(j) == ' ') {
                returnIndent += " ";
                j++;
              }

              fixedProperMethodBody += returnIndent + splitLines[0].trim() + "\n";

              String[] returnLines = splitLines[1].split(";");
              if(returnLines.length > 1 && returnLines[1].trim().length() > 0) {
                fixedProperMethodBody += returnIndent + "  return " + returnLines[0].trim() + ";\n" + returnIndent + returnLines[1].trim() + "\n";
              } else {
                fixedProperMethodBody += returnIndent + "  return " + splitLines[1].trim() + "\n";
              }
            } else {
              fixedProperMethodBody += properMethodLines[i] + "\n";
            }
          }

          properMethodBody = fixedProperMethodBody;

          String properMethodIndent = "";
          int indentIndex = 0;
          while(indentIndex < properMethodBody.length() && properMethodBody.charAt(indentIndex) == ' ') {
            properMethodIndent += " ";
            indentIndex++;
          }

          // inject the after injection code after every return, while appropriate indentation
          for(int i = -1; (i = properMethodBody.indexOf("return", i + 1)) != -1; ) {
          
            //Check if return statement is on its own line
            int lastChar = i - 1;
            while (properMethodBody.charAt(lastChar) == ' ')
            lastChar--;
            if (properMethodBody.charAt(lastChar) != '\n') // If it has any non-space characters before it, it's invalid
              continue;
            // determine the indentation of the return
            String indent = "";
            while(i >= 1 && properMethodBody.charAt(--i) == ' ') {
              indent += " ";
            }

            // Need to determine if block has braces surrounding it. To do this, take the previous
            // lines of code and apply some regex to remove all of the comments.
            String[] previousLinesOfCode = properMethodBody.substring(0, i+1).replaceAll("\\/\\*([\\S\\s]+?)\\*\\/", "").replaceAll("(?s)/\\*.*?\\*/", "").replaceAll("//.*$", "").split("\\n");
            int commentLineCount = properMethodBody.substring(0, i+1).split("\\n").length - previousLinesOfCode.length;

            // set previousLine to be the first non-empty line
            int previousLine = -1;
            for(int j = previousLinesOfCode.length - 1; j >= 0; j--) {
              if(previousLinesOfCode[j].trim().length() > 0) {
                previousLine = j;
                break;
              }
            }

            String previousLineStr = previousLinesOfCode[previousLine].trim();

            // Need to subtract the number of lines of comments between the return and the previous line of code
            while(!properMethodBody.split("\\n")[previousLine + commentLineCount].trim().equals(previousLineStr)) {
              commentLineCount--;
            }

            // If we need to, insert braces, otherwise continue as normal
            String indentedCustomAfterInjectionCode = GeneratorHelper.doIndent("\n" + customAfterInjectionCode, indent);

            i += indent.length() + 1;
            String[] returnAndRest = properMethodBody.substring(i).split("\n", 2);
            properMethodBody = properMethodIndent + properMethodBody.substring(0, i).trim() + indentedCustomAfterInjectionCode + "\n" + indent + returnAndRest[0].trim() + "\n" + returnAndRest[1];
            i += indentedCustomAfterInjectionCode.length() + 4;
          }

          // if the last line isn't a return, insert the injection at the very end
          String[] lines = properMethodBody.split("\\n");
          if(!lines[lines.length-1].contains("return")) {
            properMethodBody += GeneratorHelper.doIndent("\n" + customAfterInjectionCode, "    ");
          }
        }
      }
    	
      appendln(realSb, properMethodBody);

      if(!properMethodBody.contains("return"))
      {
        if (customAfterInjectionCode != null) { append(realSb, "{0}\n",GeneratorHelper.doIndent(customAfterInjectionCode, "    "));}
      }

    	
	  appendln(realSb, "  end");
  }
#>>

!>>
}
