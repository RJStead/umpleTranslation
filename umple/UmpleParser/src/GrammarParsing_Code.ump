/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

*/

class Analyzer
{
  
  /*
   * Analyzes the token tree by instantiating the appropriate analyzer
   * for each token rule.
   *
   * Note: This method makes heavy use of reflection
   * Todo: consider simplifying and making use of the inheritance structure
   */
  public void analyzeToken(Token token)
  {
    prepare(token);
    for(Token subtoken:token.getSubTokens())
    {
      for(Analyzer analyzer:children)
      {
        if(analyzer.getName().equals(subtoken.getName()))
        {
          List<Class> classes = new ArrayList<Class>();
          List<String> variables = new ArrayList<String>();
          for(Field field:analyzer.getClass().getDeclaredFields())
          {
            Class<? extends Analyzer> clazz = this.getClass();
            while(clazz!=null&&!"Analyzer".equals(clazz.getSimpleName()))
            {
              for(Field mfield:clazz.getDeclaredFields())
              {
                if(field.getName().equals(mfield.getName()))
                {
                  try 
                  {
                    classes.add(field.getType());
                    variables.add(field.getName().substring(0,1).toUpperCase()+field.getName().substring(1));
                    break;
                  }catch (IllegalArgumentException e){
                    throw new IllegalStateException("Illegal argument encountered", e);
                  }catch (NullPointerException e){
                    throw new IllegalStateException("Null state encountered", e);
                  }
                }
              }
              clazz = (Class<? extends Analyzer>)clazz.getSuperclass();
            }
          }
          try{
            List<Analyzer> originalChildren = analyzer.getChildren();
            analyzer = analyzer.getClass().newInstance();
            for(Analyzer child:originalChildren)
            {
              analyzer.addChild(child);
            }
            for(int i=0;i<classes.size();++i)
            {
              Object object = this.getClass().getMethod("get"+variables.get(i),new Class[]{}).invoke(this);
              analyzer.getClass().getMethod("set"+variables.get(i),new Class[]{classes.get(i)}).invoke(analyzer,object);
            }
          } catch (SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException e) {
           throw new IllegalStateException("Error instantiating method", e);
          }
          analyzer.analyzeToken(subtoken);
          break;
        }
      }
    }
    analyze(token);
  }
  
  /* 
   * Prepare is called before analyzing the token, allowing edits or 
   * sanitizing to be done
   */
  public void prepare(Token token){}
  
  /*
   * Analyze is called to analyze the particular token
   */
  public void analyze(Token token){}

  public String toString()
  {
    return "Analyzer:"+getName();
  }
  
}

class RuleBasedParser 
{
  //This variable exists to speed up multiple passes through the parser, say in junit tests, because the grammar analysis only has to be performed once.
  private static GrammarAnalyzer analyzer = null;
  private Token grootToken = null;

  public static GrammarAnalyzer getAnalyzer()
  {
    return analyzer;
  }

  public Token getGRootToken()
  {
    return grootToken;
  }

  /*
    This method helps to clean the string value of a token by tranforming an unicode character into its value. Such as semicolon "\u003B" into ";".
    It supports \u003B ---> semicolon. This method can extended to support other unicode characters.
  */
  private void cleanEscapeChars(Token token){

    if(token.getValue() != null)
    {
      if(token.is("value") && token.getValue().contains("\\u003B"))
        token.setValue(token.getValue().replace("\\u003B",";")); 
    } 
    for(Token subToken : token.getSubTokens())
    {
      cleanEscapeChars(subToken);
    }

}

  /*
    Takes a root rule and uses it to start parsing. The result will be put into the root token passed. The parsing will be performed
    on the file. data is a DataPackage which needs to be initialized(using the init(Position)) before passing to this function.
    The data package will contain miscellaneous data that will be computed throughout the parsing, such as FailPosition(if parsing fails)
    and the location of couples(brackets and quotes).
  */
  public void parse(ChoiceRule root, Token token, String filename, ParserDataPackage data)
  {
    parsing++;
    data.setCouples(new HashMap<String,ParsingCouple>());
    BalancedRule.initialize(data.getInput(),data);
    int parseResult = root.parse(token, 0,data.getInput().length(),data.getInput(),data);
    if(parseResult==data.getInput().length())
    {
      cleanEscapeChars(token);cleanEscapeChars(token);
      setRootToken(token);
    }
    else
    {
      setRootToken(token);
      setFailedPosition(data.getPosition());
    }
    parsing--;
  }
  
  /*
   * Adds a parser action to operate on an action token of the specified name
   *
   * @param name the name of the token to perform the action
   * @param action the ParserAction to perform
   */
  void addParserAction(String name, ParserAction action){
    actionedTokens.put(name,action);
  }


  public void parse(ChoiceRule root, Token token, String filename,int line, ParserDataPackage data)
  {
    parsing++;
    data.setCouples(new HashMap<String,ParsingCouple>());
    BalancedRule.initialize(data.getLine(line),data);
    int parseResult = root.parse(token, 0,data.getLine(line).length(),data.getLine(line),data);
    if(parseResult==data.getInput().length())
    {
      cleanEscapeChars(token);
      setRootToken(token);
    }
    else
    {
      setRootToken(token);
      setFailedPosition(data.getPosition());
    }
    parsing--;
  }

  public void setupRules()
  {
    setupRules(true);
  }

  /**
   * After being passed all the grammar files by the UmpleInternalParser, this function is called to compute all the rules that are associated
   * to the umple language. For some reason this is computationally expensive, future implementations will hopefully be able to speed this up.
   */
  public void setupRules(boolean forceParse)
  {
    BufferedReader reader = null;
    InputStream resourceStream = null;
    boolean mustParse = true;
    try {
      File rulesfile = new File(new File("cruise.umple").getAbsolutePath()+File.separator+"bin"+File.separator+"rules.grammar");

      if(rulesfile.exists()&&rulesfile.canRead())
      {
        reader = new BufferedReader(new FileReader(rulesfile));
      }
      else
      {
        resourceStream = getClass().getResourceAsStream(File.separator+"rules.grammar");
        if(resourceStream == null)
        {
          mustParse = true;
          reader = null;
        }
        else
        {
          reader = new BufferedReader(new InputStreamReader(resourceStream));  
        }          
      }
      if(mustParse || forceParse)
      {
        readGrammarFiles();
        if(rulesfile.exists()&&rulesfile.canWrite()){
          rulesfile.delete();
        }
        /*
        if(!rulesfile.exists())
        {
          if(new File("cruise.umple"+File.separator+"bin"+File.separator+"umple_core.grammar").canWrite())
          {
            rulesfile.createNewFile();
          }
          if(!rulesfile.canWrite()){
            return;
          }
          BufferedWriter writer = new BufferedWriter(new FileWriter(rulesfile));
          writer.write("");
          writer.append(analyzer.getRules().get("$ROOT$").toDeclareString(new StringBuilder()));
          writer.append("//END DECLARE\n");
          analyzer.getRules().get("$ROOT$").resetDeclare();
          writer.append(analyzer.getRules().get("$ROOT$").toCannotBeString(new StringBuilder()));
          writer.append("//END CANNOTBE\n");
          analyzer.getRules().get("$ROOT$").resetDeclare();
          writer.append(analyzer.getRules().get("$ROOT$").toRedoRegexString(new StringBuilder()));
          writer.append("//END REDOREGEX\n");
          writer.close();

          analyzer.getRules().get("$ROOT$").resetDeclare();
        }
        */
      }
      else if(reader!=null)
      {
        String program = null;
        String currentLine = reader.readLine();
        if(analyzer==null)
        {
          analyzer = new GrammarAnalyzer();
          analyzer.setLinkedFileHandler(getLinkedFileHandler());
          analyzer.setAnalyzerGenerator(getAnalyzerGenerator());
          // Add all the parser actions to the analyzer
          for( Map.Entry<String,ParserAction> entry : actionedTokens.entrySet() ){
            analyzer.addParserAction(entry.getKey(), entry.getValue());
          }
        }

        analyzer.getKeys().put("{}", new String[]{"{","}"});    
        analyzer.getKeys().put("\"", new String[]{"\"","\""});
        analyzer.getKeys().put("<<!!>>", new String[]{"<<!","!>>"});    
        analyzer.getKeys().put("<<##>>", new String[]{"<<#","#>>"});
        analyzer.getKeys().put("<<=>>", new String[]{"<<=",">>"});    
        analyzer.getKeys().put("<</**/>>", new String[]{"<</*","*/>>"});
        analyzer.getKeys().put("<<$>>", new String[]{"<<$",">>"});
        analyzer.getKeys().put("<<@>>", new String[]{"<<@",">>"});

        while(currentLine!=null){    
          if(currentLine.equals("//END DECLARE")){
            currentLine = reader.readLine();
            break;
          }
          String value = reader.readLine();


          todeclare.put(currentLine,value);
          if(program==null){
            program = currentLine;          
          }
          currentLine = reader.readLine();
        }
        while(currentLine!=null)
        {
          if(currentLine.equals("//END CANNOTBE"))
          {
            currentLine = reader.readLine();
            break;
          }
          int colon = currentLine.indexOf(":");
          String name = currentLine.substring(0,colon);
          evaluate(name);
          ((Terminal)choicerules.get(name)).setCannotBe(currentLine.substring(colon+1));
          currentLine = reader.readLine();
        }
        while(currentLine!=null)
        {
          if(currentLine.equals("//END REDOREGEX"))
          {
            currentLine = reader.readLine();
            break;
          }
          int colon = currentLine.indexOf(":");
          String name = currentLine.substring(0,colon);
          int colon2 = currentLine.indexOf(":",colon+1);
          evaluate(name);
          String regex =((Terminal)choicerules.get(name)).getRegex();
          if(choicerules.get(name).getOptional())
          {
            regex = regex.substring(0,regex.length()-1);
          }
          ((Terminal)choicerules.get(name)).redoRegex(regex,currentLine.substring(colon2+1),Boolean.parseBoolean(currentLine.substring(colon+1,colon2)));
          currentLine = reader.readLine();
        }
        evaluate(program);
        analyzer.set("$ROOT$",choicerules.get(program));
        reader.close();
      }
    } 
    catch (IOException e)
    {
      e.printStackTrace();
    }
  }
  
  /*
   * Takes a file and parses it, returning the ParseResult
   * 
   * @param file the file to parse
   * 
   * @return the result of this parsing as a ParseResult
   */
  public ParseResult parse(File file, File[] linkedFiles)
  {
    if(analyzer==null)
    {
      setupRules();
    }
    if( linkedFiles != null){
      analyzer.init(file, linkedFiles);
    }
    analyzer.execute();
    setRootToken(analyzer.getRootToken());
    cleanEscapeChars(analyzer.getRootToken());
    setParseResult(analyzer.getParseResult());
    return getParseResult();
  }
  
  /*
   * Takes a file and parses it, returning the ParseResult
   * 
   * @param file the file to parse
   * 
   * @return the result of this parsing as a ParseResult
   */
  public ParseResult parse(File file){
    return parse(file, new File[0]);
  }

  public ParseResult parse(String ruleName, String input)
  {
    return parse(ruleName,input,"temp",null,0,0);
  }
  
  public ParseResult parse(String ruleName, String input,String fileName,Position position ,int lineNumber, int offset)
  {
    if(analyzer==null)
    {
      setupRules();
    }
    analyzer.init(ruleName, input,fileName,position ,lineNumber, offset) ;   
    
    analyzer.execute();
    setRootToken(analyzer.getRootToken());
    cleanEscapeChars(analyzer.getRootToken());
    setParseResult(analyzer.getParseResult());
    return getParseResult();
  }
  

  public static boolean evaluate(String hash)
  {
    String currentLine = todeclare.get(hash);
    if(currentLine==null)
    {
      return false;
    }
    String[] args = currentLine.split("[:]");
    String type = args[0];
    String name = args[1];
    if(type.equals("ChoiceRule"))
    {
      choicerules.put(hash,new ChoiceRule(name));
      if(name.equals("useStatement"))
      {
        choicerules.get(hash).setAction(analyzer.getActionedTokens().get("useStatement"));
      }
    }
    else if(type.equals("ChainRule"))
    {
      choicerules.put(hash,new ChainRule(name));
      
    }
    else if(type.equals("RepeatableRule"))
    {
      choicerules.put(hash,new RepeatableRule(name,Integer.parseInt(args[6]),Integer.parseInt(args[7])));
    }
    else if(type.equals("BalancedRule"))
    {
      BalancedRule rule = new BalancedRule(name,args[6],args[7]);
      rule.setNoSpaces("true".equals(args[8]));
      choicerules.put(hash,rule);
    }
    else if(type.equals("RootRule")){
      choicerules.put(hash,new RootRule(name));
    }
    else if(type.equals("Terminal"))
    {
      String regex = currentLine.substring(
        currentLine.indexOf(":",
          currentLine.indexOf(":",
            currentLine.indexOf(":",
              currentLine.indexOf(":",
                currentLine.indexOf(":",
                  currentLine.indexOf(":",
                    currentLine.indexOf(":",
                      currentLine.indexOf(":",
                        currentLine.indexOf(":",
                          currentLine.indexOf(":",
                            currentLine.indexOf(":")+1)+1)+1)+1)+1)+1)+1)+1)+1)+1)+1);
      Terminal terminal = null;
      if(args[9].equals("true"))
      {
        terminal = new Terminal(name,regex);
      }
      else
      {
        terminal = new Terminal(name,regex,args[10].equals("true"));
      }
      if(args[6].equals("true"))
      {
        terminal.onlyValue();
      }
      if(args[7].equals("true"))
      {
        terminal.setCanBeNull(true);
      }
      if(args[8].equals("true"))
      {
        terminal.cannotHaveNewline();
      }
      choicerules.put(hash,terminal);
    }
    choicerules.get(hash).setNegate(args[3].equals("true"));
    choicerules.get(hash).setOptional(args[4].equals("true"));
    try
    {
      choicerules.get(hash).setSubrules(args[5]);
    }
    catch(Exception e)
    {

    }
    if(analyzer.makeAnalyzer(choicerules.get(hash).getName()))
    {
      analyzer.addAnalyzerRule(choicerules.get(hash));
      analyzer.addAnalyzerFromStack();
      analyzer.setMustSetupAnalyzers(true);
    }
    
    for(int i=0;i<choicerules.get(hash).size();++i)
    {
      choicerules.get(hash).get(i);
    }
    return true;
  }
  
  void readGrammarFiles()
  {
    Terminal.space(" \\t");
    ChoiceRule rulename = new Terminal("rulename","[a-zA-Z0-9_]+",false);
    ChoiceRule definition = new RepeatableRule("definition",0,Integer.MAX_VALUE);
    ChoiceRule openbrace = new Terminal("openbrace","\\(",false).dontCare();
    ChoiceRule closebrace = new Terminal("closebrace","\\)",false).dontCare();
    ChoiceRule opencurl = new Terminal("opencurl","(\\{|\"|<<!|<</\\*|<<=|<<#|<<\\$|<<@)",false);
    ChoiceRule closecurl = new Terminal("closecurl","(\\}|\"|!>>|\\*/>>|>>|#>>|>>|>>)",false);
    ChoiceRule otherRule = new ChainRule("otherrule",new Terminal("open","\\Q[[\\E",false).dontCare(),rulename,new Terminal("close","\\Q]]\\E",false).dontCare()).dontCare();
    ChoiceRule spaceSeparated = new BalancedRule("token","[",
        new ChainRule("multi",
        new Terminal("premodifier","([~!=*]?[*]?)"),
        new Terminal("tokenname","([|][|]|[a-zA-Z0-9_,-]+)"),
        new Terminal("valuecolon","[:>]?",false),
        new Terminal("value",".*",false)).dontCare(),"]").dontCare();
    ChoiceRule options = new ChoiceRule("options",
        new ChainRule("braced",opencurl,definition,closecurl),
        new ChainRule("anonymousRule",openbrace,definition,closebrace, new Terminal("modifier","[*+?]?",false)),
        new ChainRule("otherrule",otherRule,new Terminal("modifier","[*+?]?",false)),
        new ChainRule("token",spaceSeparated,new Terminal("modifier","([*+?]?)")),
        new Terminal("separator","[|]",false),
        new Terminal("spaces","",true).dontCare(),
        new ChainRule("terminal",new Terminal("terminal","(\\Q-(\\E|\\Q-)\\E|^((?!"+((Terminal)opencurl).getRegex()+"|"+((Terminal)closecurl).getRegex()+"|\\s|\\(|\\)).)*)",false))).dontCare();

    definition.add(options);

    ChoiceRule rule = new ChoiceRule("rule",
        new ChainRule("layout",
            rulename,
            new Terminal("modifier","[-]?[#]?",false),
            new Terminal("colon","[:]",false).dontCare(),
            definition, new Terminal("newline", "[\\n]",false).dontCare()
            ).dontCare()
    );

    ChoiceRule root = rule;

    ParsingCouple.ignoreLevel = 1;
    Token rootToken = new Token("ROOT","");
    List<Thread> parsers = new ArrayList<Thread>();
    String[] keys = new String[]{"[","]"};
    rootToken = new Token("ROOT","");
    for(String filename:getGrammarFiles())
    {
      ParserDataPackage data = new ParserDataPackage(filename,getAnalyzer());
      data.getKeys().put("[]",keys);
      data.init(null);
      for(int i=0;i<data.numberOfLines();++i){
        if(!data.getLine(i).startsWith("//")&&!data.getLine(i).startsWith("\n")){
          parse(root,rootToken,filename,i, data);
        }
      }
    }
    analyzer = new GrammarAnalyzer();
    analyzer.setLinkedFileHandler(getLinkedFileHandler());
    analyzer.setAnalyzerGenerator(getAnalyzerGenerator());
    for( Map.Entry<String,ParserAction> entry : actionedTokens.entrySet() ){
      analyzer.addParserAction(entry.getKey(), entry.getValue());
    }
    analyzer.analyze(rootToken);
    analyzer.setupTerminals();
  }
  
  // retroactively change the linked file handler if an analyzer is already constructed
  void setLinkedFileHandler(LinkedFileHandler aLinkedFileHandler){
    linkedFileHandler = aLinkedFileHandler;
    if( analyzer != null ){
      analyzer.setLinkedFileHandler(aLinkedFileHandler);
    }
  }
  
  LinkedFileHandler getLinkedFileHandler(){
    return linkedFileHandler;
  }
  
  // retroactively change the analyzer generator if an analyzer is already constructed
  void setAnalyzerGenerator(AnalyzerGeneratorHandler aAnalyzerGenerator){
    analyzerGenerator = aAnalyzerGenerator;
    if( analyzer != null ){
      analyzer.setAnalyzerGenerator(analyzerGenerator);
    }
  }
  
  AnalyzerGeneratorHandler getAnalyzerGenerator(){
    return analyzerGenerator;
  }
}

class ParserDataPackage
{
  /*
    The passed Position can be null if this method was not invoked using a useStatement.
    It takes a file and reads it, it also initializes the couples which will be used for this file.
  */
  public void init(Position usePosition) 
  {
    String file = filename;
    fullFileAddress = filename;
    filename = file.split("\\Q"+File.separator+"\\E")[file.split("\\Q"+File.separator+"\\E").length-1];
    int offset = 0;
    int linenumber = 0;
    linenumbers = new LinkedHashMap<Integer,Integer>();
    BufferedReader reader = null;
    InputStream resourceStream = null;
    try {
      if ((new File(file)).exists())
      {
        reader = new BufferedReader(new FileReader(file));
      }
      else
      {
        String resourceToLoad=file;
        if(file.contains("lib:")) {
          resourceToLoad = "/"+file.substring(file.indexOf("lib:")+4);
        }
        resourceStream = getClass().getResourceAsStream(resourceToLoad);
        reader = new BufferedReader(new InputStreamReader(resourceStream));
      }
      String line = reader.readLine();
      StringBuilder input2 = new StringBuilder();
      while(line!=null)
      {
        linenumbers.put(offset, linenumber);
        offset+=line.length()+1;
        linenumber++;
        lines.add(line+"\n");
        input2.append(line+"\n");
        line = reader.readLine();
      }
      input = input2.toString();
    }
    catch(NullPointerException n)
    {
      // Special case when we don't want to read a file
      if(filename.equals("dummy__.ump")) {
        input="";
      }
      else {
        this.getParseResult().addErrorMessage(new ErrorMessage(1510,usePosition==null?new Position(filename,1,0,0):usePosition,filename));
      }
    }
    catch(IOException e)
    {
      e.printStackTrace();
    } 
    finally 
    {
      try 
      {
        reader.close();
      } 
      catch(NullPointerException n)
      {        
      } 
      catch (IOException e)
      {      
        e.printStackTrace();
      }
    }
  }
  
  /*
   * Links files together at compile-time, provided a handler and the filenames.
   * 
   * Note: This has no effect if the handler is null
   */
  public void linkFiles( LinkedFileHandler handler, File[] linkedFiles ){
    if( handler != null ){
      input = handler.onFileLink( input, linkedFiles );
    }
  }
  
  public void init(String rawinput, Position usePosition, int linenumber, int offset){
   
   linenumbers = new LinkedHashMap<Integer,Integer>();
    try {
      for(String line:rawinput.split("\\n"))
      {
        linenumbers.put(offset, linenumber);
        offset+=line.length()+1;
        linenumber++;
        input += line+"\n";
      }
    }
    catch(NullPointerException n)
    {
      if(this.getParseResult()==null)
      {
        this.setParseResult(new ParseResult(false));
      }
      // Special case when we don't want to read a file
      if(filename.equals("dummy__.ump")) {
        input="";
      }
      else {
        this.getParseResult().addErrorMessage(new ErrorMessage(1510,usePosition==null?new Position(filename,1,0,0):usePosition,filename));
      }
    }
    couples = new HashMap<String,ParsingCouple>();    
    BalancedRule.initialize(input,this);
    }
  

}
interface RuleBasedParserAction {
  public void onSuccess(cruise.umple.parser.Token token);
}

external Thread { }

class RuleBasedParserThread
{
  /*
    Each Thread will parse a separate file. When parsing is complete it will fill the useStatement token with the tokens computed from the
    file which was parsed. This run method performs this function as well as initializes the data package which will be used during the parsing
  */
  public void run()
  {
    HashMap<String,String[]> keys = data.getKeys();
    List<String> hasParsed = data.getHasParsed();
    ParseResult parseResult = data.getParseResult();
    data = new ParserDataPackage(filename, null);
    data.setKeys(keys);
    data.setHasParsed(hasParsed);
    data.setParseResult(parseResult);
    data.init(token.getPosition());
    Token temp = new Token("ROOT","");
    RuleBasedParser parser = new RuleBasedParser();
    data.setAnalyzer(parser.getAnalyzer());
    parser.parse(root,temp,filename,data);
    Token answer = parser.getRootToken();
    synchronized(token)
    {      
      if(answer!=null)
      {
        new ChoiceRule("").addAllTokens(token, answer);
      }
      token.notifyAll();
    }
  }
  /* to make it linear
  public void join() throws InterruptedException{
  }
  public void start(){
    run();
  }*/
}

class GrammarAnalyzer {
  /*
    Sets up the actionTokens, and initializes the global variable
  */
  after constructor { 
    set("anon_index",0);
    set("analyzer",this);
    set("stack",new Stack<ChoiceRule>());//new RuleStack());
    ChoiceRule root = new ChoiceRule("root");
    stacks.get("stack").push(root);
    // added extra space character issue 579 p{Z} matches non breaking space
    Terminal.space(" \\t\\n\\p{Z}"); 
    // Terminal.space(" \\t\\n");
    ParsingCouple.ignoreLevel = -1;
  }
  
  /*
   * Adds a parser action to operate on an action token of the specified name
   *
   * @param name the name of the token to perform the action
   * @param action the ParserAction to perform
   */
  void addParserAction(String name, ParserAction action){
    actionedTokens.put(name,action);
  }
  /*
    Must be called before use with the execute function, this function sets up the file for parsing
  */
  public void init(File file, File[] linkedFiles)
  {
    setFile( file );
    input = file.getAbsolutePath();
    setData(new ParserDataPackage(input,this));
    getData().setKeys(keys);
    getData().init(null);
    getData().linkFiles( getLinkedFileHandler(), linkedFiles );
  }
    
  public void init(String ruleName, String input) {
    init(ruleName,input,"temp",null,0,0);
  }
  
  public void init(String ruleName, String input, String fileName, Position usePosition, int lineNumber, int offset) {
    this.input = input;
    setData(new ParserDataPackage(fileName,this));
    getData().setKeys(keys);
    getData().init(input,usePosition,lineNumber,offset);  
  }
  /*
    Performs the parsing on the umple file.
  */
  public void execute()
  {
    setRootToken(new Token("ROOT",""));
    RuleBasedParser parser = new RuleBasedParser();
    parser.parse(rules.get("$ROOT$"),getRootToken(), input,getData());
    setRootToken(parser.getRootToken());
    while(threads.size()>0)
    {
      try 
      {
        RuleBasedParserThread thread = threads.remove(0);
        if(thread!=null)
        {
          thread.join();
        }
      } 
      catch (InterruptedException e)
      {
      }
    }
    setFailedPosition(parser.getFailedPosition());
    setParseResult(getData().getParseResult());
    if(mustSetupAnalyzers)
    {
      setupAnalyzers();
      mustSetupAnalyzers = false;
    }
  }
//--Analyze Rule Methods

  /*
    The rules token contains all the rules in a grammar file.
  */
  public void rules(Token token) {
    analyze(token);
  }
  
  public boolean makeAnalyzer(String name)
  {
    boolean wasMade = false;
    if(!getAnalyzerMap().containsKey(name)){
      Analyzer a = null;
      if( getAnalyzerGenerator() != null ){
        a = getAnalyzerGenerator().generateFromName(name);
      }
      if( a != null ){
        getAnalyzerMap().put(name,a);
        analyzerStack.push(a);
        wasMade = true;
      }
    }
    return wasMade;
  }
  /*
    The rule token denotes the beginning of a rule definition.
  */
  public void rule(Token token) 
  {
    if(rules.get(getValue(token,"rulename"))==null)
    {
      set(getValue(token,"rulename"),getFirst()?new RootRule(getValue(token,"rulename")):new ChoiceRule(getValue(token,"rulename")));
      if(getFirst())
      {
        set("$ROOT$",rules.get(getValue(token,"rulename")));
        setFirst(false);
      }
    }
    ChoiceRule self = rules.get(getValue(token,"rulename"));
    boolean hasAnalyzer = makeAnalyzer(self.getName());
    String modifier = getValue(token,"modifier");
    noSpaces = false;
    if(modifier!=null)
    {
      if(modifier.contains("-"))
      {
        self.dontCare();
      }
      if(modifier.contains("#"))
      {
        noSpaces = true;
      }
    }
    if(actionedTokens.get(self.getName())!=null)
    {
      self.setAction(actionedTokens.get(self.getName()));
    }
    stacks.get("stack").peek().add(self);
    stacks.get("stack").push(self);
    analyze(token);
    stacks.get("stack").pop();
    if(hasAnalyzer)
    {
      addAnalyzerFromStack();
      analyzerRules.add(self);
    }
  }

  public void addAnalyzerFromStack()
  {
    analyzers.add(analyzerStack.pop());
  }

  /*
    The definition token is used both for the rule definition, and anonymous rules(rules containsed within paratheses).
  */
  public void definition(Token token) {
    ChoiceRule self = new ChainRule("annoymous_multirule_"+ints.get("anon_index")).dontCare();
    set("anon_index",ints.get("anon_index")+1);
    stacks.get("stack").peek().add(self);
    stacks.get("stack").push(self);
    analyze(token);
    stacks.get("stack").pop();
  }

  /*
    Otherrule tokens are for rule names within a definition, where the otherrule is defined elsewhere.
  */
  public void otherrule(Token token) {

    String modifier = getValue(token,"modifier");
    if(modifier!=null&&modifier.length()>0)
    {
      int start = 1;
      int end = 1;
      switch(getValue(token,"modifier").charAt(0))
      {
      case '*':
        start = 0;
        end = Integer.MAX_VALUE;
        break;
      case '?':
        start = 0;
        end = 1;
        break;
      case '+':
        start = 1;
        end = Integer.MAX_VALUE;
        break;
      }
      ChoiceRule star = new RepeatableRule("annoymous_starrule_"+ints.get("anon_index"),start,end).dontCare();
      set("anon_index",ints.get("anon_index")+1);
      stacks.get("stack").peek().add(star);
      stacks.get("stack").push(star);
    }

    if(rules.get(getValue(token,"rulename"))==null)
    {
      set(getValue(token,"rulename"),new ChoiceRule(getValue(token,"rulename")));
    }
    ChoiceRule self = rules.get(getValue(token,"rulename"));
    stacks.get("stack").peek().add(self);  
    if(modifier!=null&&modifier.length()>0)
    {
      stacks.get("stack").pop();
    }
   
    if(makeAnalyzer(self.getName()))
    {
      analyzers.add(analyzerStack.pop());
      analyzerRules.add(self);
    }
  }
  /*
    Simple method to handle token values.
  */
  public String getValue(Token token, String name)
  {
    String value = null;
    for(Token sub:token.getSubTokens())
    {
      if(sub.is(name))
      {
        value = sub.getValue();
      }
    }
    return value;
  }

  /*
    Terminals are keywords or syntax.
  */
  public void terminal(Token token) 
  {
    String value = getValue(token,"terminal");
    value = value.replace("-(","(").replace("-)",")").replace("OPEN_ROUND_BRACKET","(").replace("CLOSE_ROUND_BRACKET",")");
    
    String regex = "\\Q"+value+"\\E";
    
    Terminal terminal = null;
    
    if(value.length()==0?false:(""+value.charAt(value.length()-1)).matches("[a-zA-Z]"))
    {
      terminal = new Terminal("anonymous_terminal_"+ints.get("anon_index"),"("+regex+"[a-zA-Z]?)",false);
      terminal.setCannotBe(regex+"[a-zA-Z]");
    }
    else
    {
      terminal = new Terminal("anonymous_terminal_"+ints.get("anon_index"),regex,false);
    }
    stacks.get("stack").peek().add(terminal.onlyValue());
    
    set("anon_index",ints.get("anon_index")+1);
  }

  /*
    Tokens are of the form [{premodifier}tokenname{:value}] and denote a Terminal rule where the a Token is created with the value specified by some premodifier
  */
  public void token(Token token) 
  {
    ChoiceRule terminal = null;
    String name = getValue(token,"tokenname");
    String premodifier = getValue(token,"premodifier");
    String modifier = getValue(token,"modifier");
    String value = getValue(token,"value");
    boolean makeTerminal = true;

    modifier = modifier==null?"":modifier;
    premodifier = premodifier==null?"":premodifier;
    value = value==null?"":value.replace("OPEN_ROUND_BRACKET","(").replace("CLOSE_ROUND_BRACKET",")");
    String regex;
    boolean post = false;
    if("-".equals(name)&&"||".equals(value))
    {
      name = "||";
      regex = "\\Q||\\E";
    }
    else if(name.contains(",")&&name.length()>1)
    {
      regex = "[^\\s\\{\\}\\(\\);,]+";
      String[] names = name.split(",");
      String[] numbers = value.split(",");
      for(int i=0;i<names.length;i++)
      {
        Terminal term = new Terminal(names[i],"("+regex+")"+(i<numbers.length?((numbers[i].equals("0"))?"":"?"):(i==0?"":"?")),false);
        stacks.get("stack").peek().add(term);    
      }
      return;
    }
    else
    {
      if("=".equals(premodifier))
      {
        if("".equals(value))
        {
          regex = "\\Q"+name+"\\E";
          String cannotBeRegex = "";
          value = name;
          if(value.length()==0?false:(""+value.charAt(value.length()-1)).matches("[a-zA-Z]"))
          {
            cannotBeRegex = regex+"[a-zA-Z]";
            regex += "[a-zA-Z]?";
          }
          terminal = new Terminal(name,"("+regex+")",false);
          if(!cannotBeRegex.equals(""))
          {
            ((Terminal)terminal).setCannotBe(cannotBeRegex);
          }          
          makeTerminal = false;
        }
        else
        {
          regex = value;
          Set<String> sorted = new TreeSet<String>(new Comparator<String>()
          {
            @Override
            public int compare(String o1, String o2)
            {  
              if (o1.length() > o2.length())
              {
                return -1;
              } 
              else if (o1.length() < o2.length())
              {
                return 1;
              }
              return o1.compareTo(o2);
           }
          });
          for(String val:regex.split("\\Q|\\E"))
          {
            sorted.add(val);
          }

          regex = "";
          String cannotBeRegex = "";
          String pipe = "";
          String pipe2 = "";
          for(String val:sorted)
          {
            if(val.length()==0?false:(""+val.charAt(val.length()-1)).matches("[a-zA-Z]"))
            {
              regex += pipe + "\\Q"+val+"\\E"+"[a-zA-Z]?";
              cannotBeRegex += pipe2 + "\\Q"+val+"\\E"+"[a-zA-Z]";
              pipe2 = "|";
            }
            else
            {
              regex += pipe + "\\Q"+val+"\\E";              
            }
            pipe = "|";
          }
          terminal = new Terminal(name,"("+regex+")",false);
          if(!cannotBeRegex.equals(""))
          {
            ((Terminal)terminal).setCannotBe(cannotBeRegex);
          }            
          
          makeTerminal = false;
        }
      }
      else if("~".equals(premodifier))
      {
        regex = "[a-zA-Z_]([a-zA-Z0-9_]|-[a-zA-Z0-9_])*([ \\t]*<(([^\\{\\}\\(\\);\\n\\[\\]>@]|\\[\\])*)>+)?";
      }
      else if("!".equals(premodifier))
      {
        regex = value;
      }
      else
      {
        regex = value;
        if(!"*".equals(premodifier)&&"".equals(value))
        {
          post = true;
        }
      }
    }
    if("**".equals(premodifier))
    {
      if(!"".equals(value))
      {
        regex = "^((?!"+value+").)*";
      }
      else
      {
        regex = ".*";
        post = true;
      }
    }
    else if("*".equals(premodifier))
    {
      regex = "([^\\n]*\\n\\s*)";
      ChoiceRule rule = stacks.get("stack").peek();
      if(rule.size()>0&&rule.get(0) instanceof Terminal)
      {
        ((Terminal)rule.get(0)).cannotHaveNewline();
      }
    }
    if(!"".equals(modifier))
    {
      regex = "("+regex+")"+modifier;
    }
    if(makeTerminal)
    {
      terminal = new Terminal(name,regex,false);
    }
    if("~".equals(premodifier))
    {
      closeTerminal.add((Terminal)terminal);
    }
    if("**".equals(premodifier))
    {
      terminal.setOptional(true);
      ((Terminal)terminal).setCanBeNull(true);
    }
    else if("*".equals(premodifier))
    {
      terminal = new Terminal(name,regex);
      terminal.setOptional(true);
    }
    if(post)
    {
      openTerminal.add((Terminal)terminal);
    }
    if(!"".equals(modifier))
    {
      int start = 1;
      int end = 1;
      switch(token.getValue("modifier").charAt(0))
      {
          case '*':
            start = 0;
            end = Integer.MAX_VALUE;
            break;
          case '?':
            start = 0;
            end = 1;
            break;
          case '+':
            start = 1;
            end = Integer.MAX_VALUE;
            break;
      }
      if(start==0)
      {
        terminal.setOptional(true);
      }
      terminal = new RepeatableRule("annoymous_starrule_"+ints.get("anon_index"),start,end,terminal).dontCare();
        set("anon_index",ints.get("anon_index")+1);
    }  
    stacks.get("stack").peek().add(terminal);
  }

  /*
    These are rules that are specified within brackets, and are therefore not Tokenized.
  */
  public void anonymousRule(Token token)
  {
    ChoiceRule rule = new ChoiceRule("annoymous_rule_"+ints.get("anon_index")).dontCare();
    set("anon_index",ints.get("anon_index")+1);
    int start = 1;
    int end = 1;
    String modifier = getValue(token,"modifier");
    if(modifier!=null&&modifier.length()>0)
    {
      switch(token.getValue("modifier").charAt(0))
      {
      case '*':
        start = 0;
        end = Integer.MAX_VALUE;
        break;
      case '?':
        start = 0;
        end = 1;
        break;
      case '+':
        start = 1;
        end = Integer.MAX_VALUE;
        break;
      }
    }
    ChoiceRule star = new RepeatableRule("annoymous_starrule_"+ints.get("anon_index"),start,end,rule).dontCare();
    set("anon_index",ints.get("anon_index")+1);

    stacks.get("stack").peek().add(star);
    stacks.get("stack").push(star);
    stacks.get("stack").push(rule);
    analyze(token);
    stacks.get("stack").pop();
    stacks.get("stack").pop();
  }
  
  /*
    {} and "" are special couple characters and are handled by making a BalancedRule which will ensure that the { is paired with the proper } and so on
  */
  public void braced(Token token)
  {
    ChoiceRule rule = new ChoiceRule("annoymous_rule_"+ints.get("anon_index")).dontCare();
    set("anon_index",ints.get("anon_index")+1);
    ChoiceRule multi = new ChainRule("annoymous_multirule_"+ints.get("anon_index")).dontCare();
    set("anon_index",ints.get("anon_index")+1);
    String open = getValue(token,"opencurl");
    String close = getValue(token,"closecurl");
    ChoiceRule couple = new BalancedRule("annoymous_braced_"+ints.get("anon_index"),
        open,
        rule,
        close).dontCare();
    couple.setNoSpaces(noSpaces);
    
    String key = open+close;
    if(!keys.containsKey(key))
    {
      keys.put(key,new String[]{open,close});
    }
    set("anon_index",ints.get("anon_index")+1);
    multi.add(couple);

    stacks.get("stack").peek().add(multi);
    stacks.get("stack").push(couple);
    stacks.get("stack").push(multi);
    stacks.get("stack").push(rule);
    analyze(token);
    stacks.get("stack").pop();
    stacks.get("stack").pop();
    stacks.get("stack").pop();
  }
  /*
    The separator token denotes the | in a rule. It means that everything before a separator is contained within one Rule and everything
    after the | is contained in a separate Rule. The parent to both of these rules is a ChoiceRule, meaning that each of the rules created
    will be tried.
  */
  public void separator(Token token)
  {
    stacks.get("stack").pop();
    ChoiceRule self = new ChainRule("annoymous_multirule_"+ints.get("anon_index")).dontCare();
    set("anon_index",ints.get("anon_index")+1);
    stacks.get("stack").peek().add(self);
    stacks.get("stack").push(self);
  }
  
  /*
    There are some terminals that need to use their surroundings to determine what they can and cannot take on as values
    this function iterates through all such terminals
  */
  public void setupTerminals()
  {
    for(Terminal terminal:openTerminal)
    {
      setupTerminal(terminal);
    }
    for(Terminal terminal:closeTerminal)
    {
      setupAlphanumericTerminal(terminal);
    }
  }
  /*
    Similar to the setupTerminal function this function makes sure that an alphanumeric does not take a value that is the value of then next terminal
    for instance if an association looks like * -- 1 Student sorted { }; the rolename is student not sorted.
    This works also for having * -- 1 Student sorted sorted { }; which will be a sorted list of students called sorted. (i.e. if the next one is accounted for then everything proceeds as normal)
  */
  public void setupAlphanumericTerminal(Terminal terminal)
  {
    ChoiceRule child = null;
    ChoiceRule parent = terminal;
    int index = 0;
    boolean optional = false;
    while(true)
    {
      child = parent;
      parent = parent.getParent();
      while(!(parent instanceof ChainRule)&&!(parent instanceof RepeatableRule))
      {
        child = parent;
        parent = parent.getParent();
        if(parent==null)
        {
          return;
        }
      }
      if(parent instanceof ChainRule)
      {
        index = parent.indexOf(child);
        if(index+1<parent.size())
        {
          optional = parent.get(index+1).isOptional();
          break;
        }
      }
      else if(parent instanceof RepeatableRule && ((RepeatableRule)parent).getMax()>1)
      {
        index = -1;
        optional = parent.isOptional();
        break;
      }
    }
    if(!"".equals(parent.get(index+1).getFirstValue()))
    {
      boolean shouldSet = false;
      for(String str:parent.get(index+1).getFirstValue().replace("\\Q", "").replace("\\E", "").split("|"))
      {
        if(str.matches(terminal.getRegex()))
        {
          shouldSet = true;
          break;
        }
      }
      if(shouldSet)
      {
        terminal.setCannotBe(parent.get(index+1).getFirstValue());
      }
    }
      
  }
  
  /*
    Sets up the tokens with no premodifier to make sure they stop at the right place,
    for instance [type] [=list[]]? should stop before the [], so the type only contains String, instead of String[]
  */  
  public void setupTerminal(Terminal terminal)
  {
    ChoiceRule child = null;
    ChoiceRule parent = terminal;
    int index = 0;
    boolean optional = false;
    String value = "";
    while(true)
    {
      child = parent;
      parent = parent.getParent();
      while(!(parent instanceof ChainRule)&&!(parent instanceof BalancedRule)&&!(parent instanceof RepeatableRule))
      {
        child = parent;
        parent = parent.getParent();
        if(parent==null)
        {
          return;
        }
      }
      if(parent instanceof ChainRule)
      {
        index = parent.indexOf(child);
        if(index+1<parent.size())
        {
          optional = parent.get(index+1).isOptional();
          
          if(parent.get(index+1).getFirstValue().equals(""))
          {
            value = "";
          }
          else if(parent.get(index+1).getFirstValue().charAt(parent.get(index+1).getFirstValue().length()-1)=='?')
          {
        value = parent.get(index+1).getFirstValue().substring(0,parent.get(index+1).getFirstValue().length()-1);
        }
        else
        {
          value = parent.get(index+1).getFirstValue();
        }
        /* 
        Future developements: if you have a rule [rule1] [rule2]? [rule3]?
                              then rule1 should be optionally delimited by rule2 and rule3
                              currently it is only delimited by rule2
                              the code below does this, except it does not work when the rule 3 is an alphanumeric
          if(optional)
          {
            index++;
            while(index+1<parent.size()&&parent.get(index).isOptional())
            {
              if(parent.get(index+1).getFirstValue().charAt(parent.get(index+1).getFirstValue().length()-1)=='?')
              {
            value += "|"+parent.get(index+1).getFirstValue().substring(0,parent.get(index+1).getFirstValue().length()-1);
            }
            else
            {
              value += "|"+parent.get(index+1).getFirstValue();
            }              
              index++;
            }
          }*/
          break;
        }
      }
      else if(parent instanceof BalancedRule)
      {
        if(!terminal.getRegex().equals(".*"))
        {
          terminal.redoRegex("[^\\s\\{\\}\\(\\);,]+");
        }
        return;
      }
      else if(!terminal.getRegex().equals(".*")&&parent instanceof RepeatableRule && ((RepeatableRule)parent).getMax()>1)
      {
        value = parent.get(0).getFirstValue();
        optional = parent.isOptional();
        break;
      }
    }
    if(terminal.getRegex().equals(".*"))
    {
      if(!"".equals(value))
      {
        terminal.redoRegex("^((?!"+value+").)*");
      }
    }
    else 
    {
      if(!"".equals(value))
      {
        value = value.replace(
             "[a-zA-Z_]([a-zA-Z0-9_]|-[a-zA-Z0-9_])*([ \\t]*<(([^\\{\\}\\(\\);\\n\\[\\]>]|\\[\\])*)>+)?",
             "\\s[a-zA-Z_]([a-zA-Z0-9_]|-[a-zA-Z0-9_])*([ \\t]*<(([^\\{\\}\\(\\);\\n\\[\\]>]|\\[\\])*)>+)?");

  value = value.replace(
             "[a-zA-Z_]([a-zA-Z0-9_]|-[a-zA-Z0-9_])*([ \\t]*<(([^\\{\\}\\(\\);\\n\\[\\]>@]|\\[\\])*)>+)?",
             "\\s[a-zA-Z_]([a-zA-Z0-9_]|-[a-zA-Z0-9_])*([ \\t]*<(([^\\{\\}\\(\\);\\n\\[\\@]>]|\\[\\])*)>+)?");
        
        terminal.redoRegex("([^\\s\\{\\}\\(\\);,<]|<[^>]*>+)+",
          value,
          optional);
      }
      else
      {
        terminal.redoRegex("[^\\s\\{\\}\\(\\);,]+");
      }
    }
  }
  
  public void analyze(Token tokens)
  {
    for(Token token: tokens.getSubTokens())
    {
      if(token.is("rule"))
      {
        rule(token);
      }
      else if(token.is("definition"))
      {
        definition(token);
      }
      else if(token.is("otherrule"))
      {
        otherrule(token);
      }
      else if(token.is("anonymousRule"))
      {
        anonymousRule(token);
      }
      else if(token.is("token"))
      {
        this.token(token);
      }
      else if(token.is("separator"))
      {
        separator(token);
      }
      else if(token.is("terminal"))
      {
        terminal(token);
      }
      else if(token.is("braced"))
      {
        braced(token);
      }
    }
  }
  public List<Analyzer> setupAnalyzers()
  {
    for(int i=0;i<analyzerRules.size();++i)
    {
      List<ChoiceRule> checked = new ArrayList<ChoiceRule>();
      if(analyzerRules.get(i)!=null)
      {
        List<Analyzer> children = setupAnalyzers(analyzers.get(i), analyzerRules.get(i),checked);
      
        int size = -1;
        while(children.size()!=size)
        {
          size = children.size();
          if(analyzerRules.get(i)!=null)
          {
            children.addAll(setupAnalyzers(analyzers.get(i), analyzerRules.get(i),checked));
          }
        }
        for(Analyzer analyzer:children)
        {
          analyzers.get(i).addChild(analyzer);
        }
      }
    }
    return null;
  }
  
  public List<Analyzer> setupAnalyzers(Analyzer analyzer, ChoiceRule parent, List<ChoiceRule> checked)
  {
    List<Analyzer> children = new ArrayList<Analyzer>();
    if(parent==null)return children;
    for(int i=0;i<parent.size();++i)
    {
      if(!checked.contains(parent.get(i)))
      {
        checked.add(parent.get(i));
        
        if(parent.get(i) instanceof Terminal)
        {
          if(makeAnalyzer(analyzer.getName()+parent.get(i).getName().substring(0,1).toUpperCase()+parent.get(i).getName().substring(1)))
          {
            Analyzer a = analyzerStack.pop();
            a.setName(parent.get(i).getName());
            children.add(a);
            analyzers.add(a);
            analyzerRules.add(parent.get(i));
          }
          else if(makeAnalyzer(parent.get(i).getName()))
          {
            Analyzer a = analyzerStack.pop();
            children.add(a);
            analyzers.add(a);
            analyzerRules.add(parent.get(i)); 
          }
          else if(analyzerRules.contains(parent.get(i)))
          {
            children.add(analyzers.get(analyzerRules.indexOf(parent.get(i))));
          }
        }
        else if(analyzerRules.contains(parent.get(i)))
        {
          children.add(analyzers.get(analyzerRules.indexOf(parent.get(i))));
        }
        else
        {
          children.addAll(setupAnalyzers(analyzer,parent.get(i),checked));
        }
      }
    }
    return children;
  }
}

